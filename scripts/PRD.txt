Module: API Standards & Documentation
REQ-API-DOC-001
Requirement Type: API, Documentation
Description: All API endpoints defined within this system MUST be documented using the OpenAPI Specification (OAS) v3.x format. This documentation MUST detail the endpoint path, HTTP method, parameters (path, query, header, cookie), request bodies (including schema definition using JSON Schema), possible responses (including HTTP status codes and response body schemas using JSON Schema), and security schemes used (referencing the OAuth 2.0 configuration for Auth0).
Rationale: Ensures clear, machine-readable documentation for API consumers (client developers, testers, other services), facilitates automated testing, and promotes consistent API design.
Acceptance Criteria:
An up-to-date OAS v3.x document (e.g., openapi.yaml or openapi.json) exists in the backend codebase or is dynamically generated.
Every implemented API endpoint is accurately reflected in the OAS document.
The OAS document passes validation against the OAS v3.x schema.
Request and response schemas are defined clearly using JSON Schema.


Priority: Must Have
Standard/Reference: OpenAPI Specification v3.x, JSON Schema

Module: Development Methodology & Quality Assurance

REQ-DEVTEST-001: Backend Development & Testing Standards
Requirement Type: Non-Functional, Quality Assurance, Development Process
Description: The backend system development MUST adhere to Test-Driven Development (TDD) principles and be supported by a comprehensive, automated testing strategy. The goal is to ensure high code quality, functional correctness, security, and maintainability. All new features, bug fixes, and refactoring MUST be accompanied by appropriate tests.
I. Test-Driven Development (TDD) Adherence:
Red-Green-Refactor: For new functionality, particularly at the unit and integration level, tests (initially failing - "Red") MUST be written before the implementation code. Implementation code is then written to make these tests pass ("Green"), followed by refactoring of both test and implementation code for clarity and efficiency while ensuring tests continue to pass.
Test Granularity: TDD should primarily focus on unit tests and fine-grained integration tests to guide design and ensure individual components function as expected.
II. Test Types & Coverage:
A comprehensive suite of automated tests MUST be developed, including:
Unit Tests:
Scope: Test individual functions, methods, classes, or modules in isolation.
Dependencies: External dependencies (databases, external services, other modules) MUST be mocked or stubbed.
Coverage: Aim for high unit test coverage of business logic, helper functions, and complex algorithms (e.g., task graph generation, condition evaluation).


Integration Tests:
Scope: Test the interaction between two or more components or layers of the application (e.g., API controllers and service layers, service layers and data access layers/repositories).
Dependencies: May involve a real test database instance or in-memory versions for faster execution, but external third-party services (Auth0, OneSignal, Payment Gateway, AI Services) SHOULD still be mocked or stubbed to ensure test reliability and avoid external dependencies.
Focus: Verify data flow, contract adherence between components, and basic interaction logic.


API / End-to-End (E2E) Tests:
Scope: Test the full request/response cycle of every API endpoint as a black box, from HTTP request to HTTP response, including database interactions.
Environment: Run against a deployed instance of the application in a dedicated, controlled test environment with its own database.
Coverage: Every API endpoint (as defined in the OAS) MUST have E2E tests covering the scenarios detailed in Section III.


Security Tests:
While many security aspects are covered by robust functional E2E tests (e.g., authorization), specific security tests SHOULD be considered for:
Verifying security header implementation (REQ-SEC-MISCONF-001).
Testing against common OWASP Top 10 vulnerabilities where static analysis or functional tests might not suffice (e.g., specific SSRF probes if applicable, complex access control bypass attempts).
These can be a mix of automated tests and manual penetration testing activities (covered by a separate security assessment plan).




III. API / End-to-End Test Case Scenarios (for every relevant endpoint):
For each API endpoint, tests MUST cover various flows, including but not limited to:
Successful Operations ("Happy Path"):
Valid input data that meets all business rules.
Verification of:
Correct HTTP Status Code (e.g., 200 OK, 201 Created, 204 No Content).
Response Headers (e.g., Content-Type, Location for POST).
Response Body Structure (MUST match the OpenAPI Specification schema).
Correctness of data values within the response body.
Correct state changes in the database (e.g., new record created, existing record updated/deleted, related records affected).
Correct invocation of mocked external services (e.g., an email being "sent").




Input Validation Failures (aligns with REQ-SEC-INJECT-001, REQ-SEC-INJECT-003, DataPoints.validation_rules):
Missing required fields in request body/query/path.
Incorrect data types for fields.
Data violating length constraints (min/max).
Data violating range constraints (min/max for numbers).
Data in invalid formats (e.g., malformed email, invalid UUID, incorrect date format).
Invalid enum values.
Attempts to inject basic malicious payloads (e.g., simple XSS strings, SQLi-like characters) to ensure sanitization/parameterization holds.
Verification of:
Correct HTTP Status Code (typically 400 Bad Request or 422 Unprocessable Entity).
Error response body structure (consistent, informative, non-sensitive error messages).




Authentication Failures (aligns with REQ-AUTH-002):
Request without Authorization header.
Request with an invalid, expired, or malformed JWT.
Verification of:
Correct HTTP Status Code (typically 401 Unauthorized).




Authorization Failures (aligns with REQ-SEC-BAC-001, REQ-SEC-BAC-002, REQ-AUTHZ-...):
User with an insufficient role attempting the action.
User attempting to access/modify a resource not owned by them or their company (IDOR scenarios).
User attempting actions restricted by specific attributes (e.g., non-lawyer attempting lawyer-only task step).
Verification of:
Correct HTTP Status Code (typically 403 Forbidden).




Business Logic & State Violation Failures:
Operations violating defined business rules or constraints (e.g., creating a duplicate unique resource, violating REQ-TEAM-007 for legal teams, attempting to publish an incomplete petition template REQ-PTMPL-VALIDATE-001).
Attempting actions on resources in an invalid state (e.g., trying to modify a 'PUBLISHED' petition template in ways only allowed for 'DRAFT').
Verification of:
Correct HTTP Status Code (e.g., 409 Conflict, 422 Unprocessable Entity, or other appropriate 4xx codes).
Informative error messages in the response body.




Resource Not Found Failures:
Attempting GET, PATCH, PUT, DELETE operations on non-existent resource IDs.
Verification of:
Correct HTTP Status Code (typically 404 Not Found).




Idempotency (for PUT, DELETE, and safe POST operations):
Ensure that making the same request multiple times has the same effect on system state as making it once.


Pagination & Filtering Tests (for list endpoints):
Verify correctness of paginated results (limit, offset, total counts).
Verify filtering logic for all supported filter parameters.
Test edge cases for pagination (e.g., empty list, page beyond total).


IV. Testing Environment & Data Management:
Dedicated Test Environment: All automated tests (especially integration and E2E) MUST run in a dedicated, isolated test environment.
Test Data:
A consistent strategy for managing test data MUST be implemented (e.g., database seeding scripts, fixture libraries, data factories).
Tests MUST be independent and not rely on the state left by previous tests. Each test or test suite should set up its required data and, if necessary, tear it down.
PII or sensitive production data MUST NOT be used in test environments. Anonymized or realistically fabricated data should be used.


V. Test Automation & CI/CD Integration:
Automation: All unit, integration, and primary E2E tests MUST be automated.
CI/CD Pipeline: Tests MUST be integrated into the CI/CD pipeline and run automatically on every code commit/push to main branches and before any deployment.
Build Failure: The CI/CD pipeline MUST be configured to fail the build or deployment if any tests fail.
VI. Test Reporting & Code Coverage:
Reporting: Clear and actionable test execution reports MUST be generated by the CI/CD pipeline.
Code Coverage: Code coverage metrics MUST be tracked for unit tests (and potentially integration tests). A minimum acceptable coverage threshold (e.g., 80-90% for business-critical logic) SHOULD be defined and enforced. Low or decreasing coverage should trigger a review.
VII. Recommended Tools & Frameworks (for Node.js/Express backend):
Test Runner/Framework: Jest or Mocha.
Assertion Library: Chai (if using Mocha), or Jest's built-in assertions.
Mocking/Stubbing: Jest's built-in mocking, Sinon.JS.
API/HTTP Testing: Supertest.
Code Coverage: Jest's built-in coverage (Istanbul).
VIII. Test Readability & Maintenance:
Tests MUST be written in a clear, readable, and maintainable manner.
Test names SHOULD accurately describe the scenario being tested.
Tests should serve as living documentation of the system's expected behavior.


Rationale: To establish a rigorous development and testing culture that proactively identifies defects, ensures requirements are met, improves design through TDD, facilitates safer refactoring, and ultimately delivers a high-quality, secure, and reliable backend system.
Acceptance Criteria:
TDD practices are demonstrably followed for new feature development.
A comprehensive automated test suite exists, covering unit, integration, and API/E2E tests as specified.
API/E2E tests validate success cases, input validation, authentication, authorization, business logic errors, and resource handling for all endpoints.
Tests are integrated into the CI/CD pipeline and block failing builds/deployments.
Code coverage reports are generated and meet or exceed defined targets for critical modules.
Test data management strategy is in place and ensures test isolation.
Testing tools and frameworks are consistently used by the development team.


Priority: Must Have
Standard/Reference: Test-Driven Development (Kent Beck), Agile Testing Principles, ISTQB Syllabi, OWASP Testing Guide, Respective tool documentation.

Module: Authentication & Authorization Foundational Requirements (Refactored Paths)
REQ-AUTH-001
Requirement Type: Security, API
Description: The system MUST use Auth0 for user authentication. Client applications MUST integrate with Auth0 using the OAuth 2.0 Authorization Code Flow with Proof Key for Code Exchange (PKCE).
Rationale: Leverages a specialized third-party identity provider for robust authentication, offloading complexity. PKCE is the current best practice for native and web apps to prevent authorization code interception.
Acceptance Criteria:
Users are redirected to Auth0 for login/signup.
Successful authentication results in the client receiving an ID Token and an Access Token from Auth0.
The client securely stores the tokens according to platform best practices.


Priority: Must Have
Standard/Reference: OAuth 2.0 RFC 6749, PKCE RFC 7636, Auth0 Documentation
REQ-AUTH-002
Requirement Type: Security, API
Description: All API endpoints under the /v1/ path prefix (except potentially a public health check endpoint like /health) MUST be protected and require a valid Auth0 Access Token (JWT) presented in the Authorization: Bearer <token> HTTP header. The backend server MUST validate the JWT signature, issuer, audience, and expiration.
Rationale: Ensures only authenticated users can interact with the backend API. Standard JWT validation prevents token tampering or misuse.
Acceptance Criteria:
Requests to protected API endpoints (e.g., /users/me) without a valid Bearer token are rejected with HTTP status 401 Unauthorized.
Requests with an invalid/expired/tampered token are rejected with HTTP status 401 Unauthorized.
Requests with a valid token are passed to the next layer (Authorization).
The backend correctly configures validation parameters (Auth0 domain/issuer, API audience).
The OAS documentation accurately reflects the Bearer token security scheme for protected endpoints.


Priority: Must Have
Standard/Reference: JWT RFC 7519, OWASP A01:2021-Broken Access Control, OAS 3.x (Security Schemes)
REQ-AUTH-003
Requirement Type: Security, Auditing
Description: Successful and failed user login attempts MUST be logged for auditing purposes. Log entries MUST include User ID (if available), Timestamp (UTC), Source IP Address, User Agent, and Attempt Outcome (Success/Failure reason).
Rationale: Provides a security trail for tracking account access and identifying potential malicious activity like brute-forcing.
Acceptance Criteria:
Audit logs capture successful logins via Auth0 callback/token validation.
Audit logs capture failed login attempts reported by Auth0 (if possible via webhooks/logs) or inferred from failed token validation.
Log entries contain all specified fields.


Priority: Must Have
Standard/Reference: OWASP A09:2021-Security Logging and Monitoring Failures
REQ-AUTH-004
Requirement Type: Security, Functional, API
Description: The system MUST provide a secure logout mechanism. An API endpoint (e.g., POST /v1/auth/logout) MUST be provided. On the client, logout MUST clear locally stored authentication tokens. The backend API call SHOULD trigger Auth0 session revocation (if applicable/configured) and MUST invalidate any server-side session state tied to the access token (if any).
Rationale: Ensures user sessions are properly terminated.
Acceptance Criteria:
Client logout action clears tokens.
POST /v1/auth/logout endpoint exists and performs necessary cleanup/revocation.
Subsequent API calls using the old token are rejected.
The endpoint is documented in the OAS specification.


Priority: Must Have
Standard/Reference: OWASP A01:2021-Broken Access Control, OAS 3.x

Module: User Data Model & Management (Refactored Paths)
REQ-USER-001 (Data Model - No change)
Requirement Type: Data
Description: The system MUST persist user data in a dedicated Users table (or equivalent structure). Each user record MUST include:
id (Primary Key, UUID recommended)
auth0_user_id (Unique identifier from Auth0 JWT sub claim, Indexed)
email (Unique, Indexed, PII)
first_name (PII)
last_name (PII)
role (Enum: 'CLIENT', 'VENDOR_EMPLOYEE', 'VENDOR_MANAGER', 'VENDOR_ADMIN', 'NN_EMPLOYEE', 'NN_MANAGER', 'NN_ADMIN')
is_lawyer (Boolean, default: false)
company_id (Foreign Key referencing Companies table, nullable for Clients initially?) - Self-correction: Clients need association later -> company_id (FK to Companies, NULL only if a client hasn't started a petition with a specific vendor yet, otherwise linked to the Vendor/NN).
created_at (Timestamp)
updated_at (Timestamp)
is_active (Boolean, default: true)
REQ-USER-002
Requirement Type: Functional, API
Description: Currently, in the recently implemented system, the user has two options: a sign-up (POST /v1/auth/signup) and a login (POST /v1/auth/login). Login is not available to users who have not signed up. They are requested to provide their first name, last name, email, and password to sign up. Upon the first successful login/token validation after Auth0 signup, the backend MUST ensure a corresponding user record exists in the Users table. If not, it MUST be created using information from the Auth0 ID token (e.g., sub, email, given_name, family_name). The initial role MUST be 'CLIENT'. The company_id can be determined based on the client application flavor (see REQ-APP-001).
Rationale: Ensures seamless user onboarding. Establishes default role and links client based on app flavor.
Acceptance Criteria:
Backend logic (e.g., middleware or dedicated service) checks for user existence on first authenticated request using auth0_user_id.
User record is created if it doesn't exist, populated from token claims.
Initial role is 'CLIENT'.
company_id is set based on app flavor context.
Relevant Auth endpoints (/v1/auth/signup, /v1/auth/login - likely handled mostly by Auth0 redirects/callbacks, but backend sync is key) are conceptually understood and user creation logic is tied to successful authentication.


Priority: Must Have
Standard/Reference: -
REQ-USER-003
Requirement Type: Functional, API, Security
Description: An API endpoint MUST exist for National Niner Admins (NN_ADMIN) to create new National Niner users (NN_EMPLOYEE, NN_MANAGER, NN_ADMIN). The endpoint (POST /users/nn-invite) MUST allow specifying email, first_name, last_name, role, and is_lawyer status. The newly created user record should be linked to the National Niner company record. An invitation mechanism (e.g., email invite handled via Auth0) should be triggered.
Rationale: Allows NN Admins to provision internal user accounts securely.
Acceptance Criteria:
POST /users/nn-invite endpoint exists.
Only NN Admins can call this endpoint.
Accepts required user details.
New User record created correctly.
Invitation sent via Auth0.
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-USER-004
Requirement Type: Functional, API, Security
Description: An API endpoint MUST exist for Vendor Admins (VENDOR_ADMIN) to create new users (VENDOR_EMPLOYEE, VENDOR_MANAGER) within their own company. The endpoint (POST /users/vendor-invite) MUST allow specifying email, first_name, last_name, role, and is_lawyer status. The API MUST enforce that the admin can only create users for their assigned company_id. An invitation mechanism should be triggered.
Rationale: Allows Vendor Admins self-service user management.
Acceptance Criteria:
POST /users/vendor-invite endpoint exists.
Only Vendor Admins can call this endpoint.
Authorization enforces company boundary.
New User record created correctly.
Invitation sent via Auth0.
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-USER-005 (Revised for Deactivation/Deletion Logic)
Requirement Type: Functional, API, Security
Description: An API endpoint (PATCH /v1/admin/users/{userId}) MUST exist for authorized administrators (NN Admins for any user; Vendor Admins for users within their own company) to modify user details. Allowed modifications:
Update user's role (within permitted role transitions, e.g., VENDOR_EMPLOYEE to VENDOR_MANAGER within the same company type).
Update user's is_lawyer status.
Update user's is_active status (activate/deactivate).
Deactivation/Deletion Handling:
When deactivating (is_active=false) a user:
If the user is an owner of any active teams (Teams.owner_user_id), the deactivation operation MUST be blocked with an error message, requiring team ownership to be reassigned first (via REQ-TEAM-005).
Active tasks (TaskInstances) assigned to the user (TaskInstances.assigned_user_id) MUST have their assigned_user_id set to NULL. The system SHOULD notify the relevant team manager(s) or company admin(s) about these unassigned tasks requiring reassignment.


True deletion of user records is NOT supported in the initial version due to audit and data integrity complexities with PII and legal case data. Deactivation (is_active=false) is the standard method for removing user access.




Rationale: Provides administrative controls over user accounts. Ensures system integrity and task continuity when users are deactivated. Addresses policy for deletion vs. deactivation.
Acceptance Criteria:
PATCH /v1/admin/users/{userId} endpoint exists.
Authorization rules strictly enforce who can modify which users and which fields (NN_ADMIN has broader scope than VENDOR_ADMIN). Role transitions are validated.
Endpoint allows updating role, is_lawyer, is_active.
Changes are reflected in the database and audited (REQ-SEC-AUDIT-001).
Validation correctly blocks deactivation of team owners until reassignment.
Tasks of a deactivated user are correctly unassigned, and notifications for reassignment are triggered (mechanism TBD, could be in-app or email).
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, OWASP A01:2021-Broken Access Control, Data Integrity, OAS 3.x
REQ-USER-006
Requirement Type: Data, Security
Description: All Personally Identifiable Information (PII) fields within the Users table (e.g., email, first_name) MUST be encrypted at rest in the database using a strong, standard algorithm (e.g., AES-256). Key management procedures MUST be defined and followed.
Rationale: Protects sensitive user data from unauthorized access even if the database is compromised. Required by privacy regulations.
Acceptance Criteria:
Specified PII fields are stored encrypted in the database.
Data can be decrypted by the application for authorized use.
Key management strategy is documented.


Priority: Must Have
Standard/Reference: GDPR Art. 32, CCPA, Data Encryption Standards (AES-256)
REQ-USER-007
Requirement Type: Functional, API
Description: An API endpoint MUST exist for users to retrieve their own profile information (GET /users/me). The returned data MUST only include non-sensitive fields necessary for the user interface (e.g., name, email, role, company name, lawyer status).
Rationale: Allows users to view their own basic profile details.
Acceptance Criteria:
GET /users/me endpoint exists.
Returns profile information for the authenticated user.
Does not expose sensitive internal IDs or unnecessary PII.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: OAS 3.x

Module: Company Data Model & Management (Refactored Paths)
REQ-COMP-001
Requirement Type: Data
Description: The system MUST persist company data in a dedicated Companies table (or equivalent). Each record MUST include:
company_id (Primary Key, UUID recommended)
name (Company name, Unique)
type (Enum: 'NATIONAL_NINER', 'VENDOR')
status (Enum: 'PENDING_APPROVAL', 'ACTIVE', 'SUSPENDED', 'REJECTED') - for Vendors
created_at (Timestamp)
updated_at (Timestamp)
billing_plan_id (Nullable FK to a BillingPlans table) - for Vendors
primary_contact_user_id (Nullable FK to Users table) - Initially the self-registering admin
submitted_documents_ref (Reference to stored documents for verification, e.g., path in object storage) - for Vendors


Rationale: Defines the structure for representing National Niner and Vendor companies, including status for the vendor approval workflow and billing info.
Acceptance Criteria:
Database schema includes the Companies table with specified fields and constraints.
A single 'NATIONAL_NINER' type company record exists (can be seeded).
Enum values for type and status are defined.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-COMP-002
Requirement Type: Functional, API
Description: A public-facing API endpoint MUST exist for prospective vendors to register their company (POST /companies/register-vendor). This endpoint MUST accept company name, primary contact details (email, first name, last name - which will create the initial VENDOR_ADMIN user), and potentially initial document uploads for verification.
Rationale: Enables vendor self-registration.
Acceptance Criteria:
POST /companies/register-vendor endpoint exists.
Accepts required details.
Creates Company (status 'PENDING_APPROVAL') and initial User (role 'VENDOR_ADMIN') records.
Handles verification document upload securely (links to File Management reqs).
Sends notifications (user confirmation, NN admin alert).
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: OAS 3.x
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for National Niner Admins (NN_ADMIN) to manage Vendor companies:
GET /v1/admin/companies?status=PENDING_APPROVAL&type=VENDOR: List vendor company applications awaiting approval. Supports pagination and filtering.
GET /v1/admin/companies/{companyId}: View details of a specific Vendor company, including submitted verification documents.
PATCH /v1/admin/companies/{companyId}/approve: Approve a vendor company application, changing its status to 'ACTIVE'.
PATCH /v1/admin/companies/{companyId}/reject: Reject a vendor company application, changing status to 'REJECTED'. Reason for rejection should be recordable and communicable.
PATCH /v1/admin/companies/{companyId}/status: Update an active Vendor company's status (e.g., to 'SUSPENDED' or back to 'ACTIVE'). Requires {"status": "SUSPENDED" | "ACTIVE"} in body.
POST /v1/admin/companies/vendor: Allows an NN_ADMIN to directly create a new VENDOR Company record and its initial VENDOR_ADMIN user (similar to REQ-USER-004 but initiated by NN_ADMIN). This bypasses the public self-registration and approval flow for vendors directly onboarded by National Niner. The company status would be 'ACTIVE' immediately.


Rationale: Provides NN Admins with necessary tools for vendor application management and allows for direct onboarding of pre-vetted vendors.
Acceptance Criteria:
Specified endpoints exist and function as described, with appropriate authorization for NN_ADMIN role.
Company status is updated correctly in the database.
Appropriate notifications are sent to the vendor admin upon status changes.
Changes are audited (REQ-SEC-AUDIT-001).
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-COMP-004
Requirement Type: Non-Functional, Scalability (Future)
Description: The system design SHOULD consider that the number of vendors and clients may grow significantly. Database queries related to companies and users should be optimized using appropriate indexing (e.g., on company_id, role, status).
Rationale: Ensures the system remains performant as the user base expands.
Acceptance Criteria:
Key foreign keys and frequently queried fields (like status, type, role) are indexed.
Performance tests demonstrate acceptable response times for user/company lookups under simulated load (specific targets TBD).


Priority: Should Have
Standard/Reference: Database Performance Tuning
REQ-COMP-005
Requirement Type: Data, Functional
Description: The system MUST support defining different billing plans specifically for Vendors to use the white-label service. A VendorBillingPlans table is required, storing plan name, features, monthly cost, etc. The Companies table's billing_plan_id will link to this. Functionality for NN Admins to manage these plans and for integrating with a payment gateway for recurring vendor subscriptions MUST be implemented. (Detailed requirements for this billing subsystem are TBD and constitute a separate feature set).
Rationale: Supports the B2B business model for vendor white-labeling.
Acceptance Criteria:
Initial database schema includes VendorBillingPlans table with essential fields (ID, name, cost, description, feature flags).
NN Admins can CRUD VendorBillingPlans.
Mechanism to associate a Vendor company with a VendorBillingPlan.
Placeholder for recurring payment integration.


Priority: Must Have (for full Vendor functionality)
Standard/Reference: Subscription Billing Models

Module: Client Application Configuration (Refactored Paths)
REQ-APP-001
Requirement Type: Functional, Configuration
Description: The client application (Flutter) build process MUST support configuration to identify itself as either the primary National Niner app or a specific Vendor's white-label app. This configuration MUST include a unique identifier (e.g., COMPANY_ID for the vendor, or a default/null value for National Niner).
Rationale: Allows the same codebase to serve multiple vendors and the main NN brand, enabling the backend to correctly associate users and petitions.
Acceptance Criteria:
Build scripts allow injecting a COMPANY_ID during the build process (e.g., via build flags, environment variables).
The running application can access this configured COMPANY_ID.


Priority: Must Have
Standard/Reference: Mobile App Build Configuration Practices
REQ-APP-002
Requirement Type: Functional, API
Description: The client application MUST include its configured COMPANY_ID (from REQ-APP-001) in relevant API requests where the backend needs context about the application flavor (e.g., during user creation associated with /v1/auth/signup callback handling, or when initiating new petitions). This could be via a custom HTTP header (e.g., X-App-Flavor-Company-ID) or as part of the request body where appropriate and documented in the OAS.
Rationale: Provides backend context for correct company association.
Acceptance Criteria:
Client includes COMPANY_ID in specified API calls or contexts.
Backend APIs process this identifier.
Mechanism (header/body field) is documented in the relevant OAS endpoint definitions.


Priority: Must Have
Standard/Reference: API Design Best Practices, OAS 3.x

Module: Auditing (Initial Requirements)
REQ-AUDIT-001
Requirement Type: Security, Logging
Description: Critical administrative actions MUST be logged in a dedicated, tamper-evident audit log. Actions include: User creation, User role/status changes, User deactivation/activation, Company creation, Company status changes (Approval, Rejection, Suspension, Activation).
Rationale: Provides a non-repudiable record of significant changes within the system, essential for security investigations and compliance.
Acceptance Criteria:
Specified administrative actions trigger log events.
Log entries include: Timestamp (UTC), Performing User ID, Performing User Role, Action Performed, Target Resource ID (e.g., User ID, Company ID), Source IP Address, Outcome (Success/Failure).
Logs are stored securely and protected against modification (e.g., write-only access, forwarding to a dedicated log management system).


Priority: Must Have
Standard/Reference: OWASP A09:2021-Security Logging and Monitoring Failures

Module: Team Data Model & Management
REQ-TEAM-001
Requirement Type: Data
Description: The system MUST persist team data in a dedicated Teams table (or equivalent). Each record MUST include:
team_id (Primary Key, UUID recommended)
company_id (Foreign Key referencing Companies table, NOT NULL, Indexed)
name (Team name, MUST be unique within a company)
description (Optional text description)
category (Enum: 'LEGAL', 'CONVENTIONAL', default: 'CONVENTIONAL')
owner_user_id (Foreign Key referencing Users table, NOT NULL, referencing a user who MUST be a Manager or Admin within the same company)
created_at (Timestamp)
updated_at (Timestamp)
is_active (Boolean, default: true)


Rationale: Defines the core structure for teams, linking them explicitly to a company and an owner, and categorizing them for assignment rules (e.g., legal petitions).
Acceptance Criteria:
Database schema includes the Teams table with specified fields, constraints (FKs, uniqueness), and data types.
company_id ensures a team belongs to exactly one company.
Validation ensures owner_user_id references a user with role *_MANAGER or *_ADMIN from the same company_id.
Enum values for category are defined.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-TEAM-002
Requirement Type: Data
Description: The system MUST persist team membership data in a dedicated TeamMembers table (or equivalent association table). Each record MUST link a User to a Team and include:
team_member_id (Primary Key, UUID recommended)
team_id (Foreign Key referencing Teams table, NOT NULL, Indexed)
user_id (Foreign Key referencing Users table, NOT NULL, Indexed)
added_at (Timestamp)
added_by_user_id (Foreign Key referencing Users table, tracking who added the member)


Rationale: Establishes the many-to-many relationship between Users and Teams. Tracks membership attribution.
Acceptance Criteria:
Database schema includes the TeamMembers table with specified fields and constraints.
A composite unique key MUST exist on (team_id, user_id) to prevent duplicate memberships.
Validation MUST ensure the user_id being added belongs to the same company_id as the team_id.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-TEAM-003
Requirement Type: Functional, API, Security
Description: An API endpoint (POST /v1/teams) MUST exist for creating new teams.
NN Admins MUST be able to create teams for any company.
Vendor Admins MUST be able to create teams only for their own company.
The request MUST include name, company_id (for NN Admins), owner_user_id, and optionally description and category.
The system MUST validate that the specified owner_user_id is a Manager or Admin within the target company.


Rationale: Allows authorized administrators to establish new teams within the correct company structure.
Acceptance Criteria:
POST /v1/teams endpoint exists.
Authorization logic correctly restricts creation based on user role and target company_id.
Endpoint accepts required fields and validates owner eligibility.
A new Team record is created upon successful validation.
The creating user is recorded implicitly (e.g., in audit logs).
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, ABAC (company context), OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-TEAM-004
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for listing and retrieving team information:
GET /v1/teams: List teams. Should support filtering by company_id.
NN Admins can list teams for any company.
Vendor Admins/Managers can list teams only for their own company.
Vendor/NN Employees can list teams they are members of within their company.


GET /v1/teams/{teamId}: Retrieve details for a specific team.
NN Admins can retrieve any team.
Vendor Admins/Managers can retrieve any team within their own company.
Vendor/NN Employees can retrieve details only if they are a member of that team.




Rationale: Provides necessary read access to team information based on user roles and company/team affiliation.
Acceptance Criteria:
Specified endpoints exist and function as described.
Authorization logic correctly filters and restricts access based on user role, company, and team membership.
Endpoints return appropriate team data (potentially excluding sensitive details based on role).
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, ABAC, OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-TEAM-005
Requirement Type: Functional, API, Security
Description: An API endpoint (PATCH /v1/teams/{teamId}) MUST exist for updating team details (e.g., name, description, owner_user_id).
NN Admins can update any team.
Vendor Admins can update any team within their own company.
Team Owners (Managers/Admins designated in owner_user_id) can update their own team's details (name, description), but potentially not the owner field itself (only Admins can change owners).
The system MUST re-validate owner eligibility if owner_user_id is changed.


Rationale: Allows authorized users to modify existing team configurations.
Acceptance Criteria:
PATCH /v1/teams/{teamId} endpoint exists.
Authorization logic correctly restricts updates based on user role, company, and team ownership.
Endpoint accepts fields to be updated in the request body.
Validations (e.g., owner eligibility) are performed.
Team record is updated.
Audit logs capture team modification events (REQ-AUDIT-001).
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, ABAC, OWASP A01:2021-Broken Access Control, OAS 3.x
REQ-TEAM-006
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for managing team membership:
POST /v1/teams/{teamId}/members: Add a user to a team. Request body MUST include user_id.
Authorization: NN Admins can add any user (from the team's company) to any team. Vendor Admins can add any user from their company to their company's teams. Team Owners can add users from their company to their own team.
Validation: MUST ensure the user being added belongs to the same company_id as the team and is is_active=true. If the team category is 'LEGAL', this operation is allowed even if it doesn't immediately satisfy REQ-TEAM-007, but the team might become non-compliant if the last lawyer is removed later.


DELETE /v1/teams/{teamId}/members/{userId}: Remove a user from a team.
Authorization: Similar to adding members (NN Admin > Vendor Admin > Team Owner for own team).
Validation:
MUST prevent removing the Teams.owner_user_id via this endpoint (owner must be changed first via REQ-TEAM-005).
MUST prevent removing the last lawyer from a 'LEGAL' team if this action would violate REQ-TEAM-007.
If the userId being removed has active TaskInstances currently assigned to them (TaskInstances.assigned_user_id) and also associated with this teamId (TaskInstances.assigned_team_id), the removal MUST be blocked, or tasks must be unassigned first. The API should return an error indicating tasks need reassignment by a manager. (Alternative: automatically unassign, but this is less explicit). Decision: Block and require manager to reassign.




GET /v1/teams/{teamId}/members: List members of a specific team (covered by REQ-TEAM-004 detail retrieval).


Rationale: Enables management of user assignments to teams according to defined permissions, with safeguards for team ownership, legal compliance, and task continuity.
Acceptance Criteria:
POST /v1/teams/{teamId}/members and DELETE /v1/teams/{teamId}/members/{userId} endpoints exist.
Authorization logic correctly restricts membership changes.
Validations for company consistency, active user status, owner removal, last lawyer removal, and active task assignments are implemented and block operations with appropriate error messages if violated.
TeamMembers records are created/deleted accordingly.
Changes are audited (REQ-SEC-AUDIT-001).
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, ABAC, OWASP A01:2021-Broken Access Control, Data Integrity, OAS 3.x
REQ-TEAM-007
Requirement Type: Functional, Constraint
Description: When creating or updating a team's category to 'LEGAL', the system MUST verify that at least one member (including the owner) of the team has the is_lawyer flag set to true. If changing category or removing the last lawyer from a 'LEGAL' team would violate this constraint, the operation MUST be rejected.
Rationale: Enforces the business rule that teams handling legal matters must have lawyer supervision.
Acceptance Criteria:
Validation logic is implemented during team creation (POST /v1/teams).
Validation logic is implemented during team update (PATCH /v1/teams/{teamId}), specifically when changing category or owner_user_id.
Validation logic is implemented when removing a member (DELETE /v1/teams/{teamId}/members/{userId}) if the team is 'LEGAL' and the user being removed is the last lawyer.
Validation logic is implemented when updating a user's is_lawyer status (PATCH /users/{userId}) if that user is the last lawyer on any 'LEGAL' teams they belong to.
Operations violating the constraint return an appropriate error response (e.g., HTTP 409 Conflict or 422 Unprocessable Entity).


Priority: Must Have
Standard/Reference: Business Logic Constraint

Module: Authorization Model (RBAC + ABAC)
This section summarizes and formalizes the access control rules based on Roles (RBAC) and Attributes (ABAC - primarily company_id, team_id, is_owner, is_member, task_assignment, resource_sensitivity).
REQ-AUTHZ-001
Requirement Type: Security, Architecture
Description: The system's authorization model MUST implement Role-Based Access Control (RBAC) based on the defined user roles (CLIENT, VENDOR_EMPLOYEE, VENDOR_MANAGER, VENDOR_ADMIN, NN_EMPLOYEE, NN_MANAGER, NN_ADMIN). It MUST also incorporate Attribute-Based Access Control (ABAC) elements to enforce context-specific permissions (e.g., access restricted to own company, own team, assigned tasks, specific resource attributes like 'LEGAL' category or 'Lawyer Required' task).
Rationale: Provides a flexible and fine-grained authorization mechanism suitable for the complex relationships between users, companies, teams, petitions, and tasks.
Acceptance Criteria:
Authorization logic checks both the user's role and relevant attributes (company affiliation, team ownership/membership, task assignment) before granting access to resources or actions.
Access control rules are consistently applied across all relevant API endpoints.


Priority: Must Have
Standard/Reference: RBAC NIST Model, ABAC NIST Guide SP 800-162
REQ-AUTHZ-002
Requirement Type: Security, Access Control
Description: Define specific permissions and map them to roles and attributes:
(User, Company, Team Management permissions as previously defined in the file - review these for completeness based on final APIs)
Petition Template Management:
MANAGE_PETITION_TEMPLATES (CRUD, Publish, Archive, Manage all sub-components like Tabs, Criteria, Plans, Document-TaskModel associations): NN_ADMIN only.


Data Point Management:
MANAGE_DATAPOINTS: DEVELOPER or designated ADMIN (based on DataPoints.managed_by).


Document Type & Preset Management:
MANAGE_DOCTYPES_PRESETS: DEVELOPER (based on managed_by).


Task Model Management:
MANAGE_TASKMODELS: DEVELOPER or ADMIN (based on TaskModels.managed_by).


Benefit Management:
MANAGE_BENEFITS: DEVELOPER or ADMIN (based on Benefits.managed_by).


Petition Instance & Task Instance Management:
CREATE_PETITION_INSTANCE: CLIENT (attribute: own user, app flavor context).
READ_OWN_PETITION_INSTANCE: CLIENT (attribute: PetitionInstances.client_user_id == self).
READ_COMPANY_PETITION_INSTANCES: VENDOR_ADMIN, VENDOR_MANAGER, NN_ADMIN (attribute: PetitionInstances.company_id scope). VENDOR_EMPLOYEE, NN_EMPLOYEE if assigned to a task within.
SUBMIT_ROOT_FORM_TASK: CLIENT (attribute: task assigned to self, part of own petition).
READ_TASK_INSTANCE_DETAILS:
CLIENT: If task is part of their petition.
NN/VENDOR_EMPLOYEE/MANAGER: If task is assigned to them, or to their team, or part of a petition in their company/team scope.
NN_ADMIN: Any task.


SUBMIT_TASK_INPUT: CLIENT (if current step assigned to client), NN/VENDOR_EMPLOYEE/MANAGER (if current step assigned to them/team).
REVIEW_TASK_SUBMISSION (Approve/Reject): NN/VENDOR_EMPLOYEE/MANAGER (if review step assigned to them/team, respecting is_lawyer for lawyer-only steps).
ADD_TASK_COMMENT: CLIENT (on own petition's tasks), NN/VENDOR_EMPLOYEE/MANAGER (on tasks they can access).
REASSIGN_TASK_INSTANCE: NN_MANAGER, VENDOR_MANAGER (within own team/company), NN_ADMIN (any task).
UPGRADE_TASK_INSTANCE: CLIENT (for own tasks), potentially NN/VENDOR_MANAGER/ADMIN (if business rule allows).
PURCHASE_ADDON: CLIENT (for own petitions).
DOWNLOAD_COMPILED_PETITION: CLIENT (own petition), NN/VENDOR_EMPLOYEE/MANAGER/ADMIN (scoped to company/assignment).
UPDATE_FILING_PROGRESS: NN/VENDOR_EMPLOYEE/MANAGER (assigned to filing).
ADD_PETITION_UPDATE: CLIENT (own petition), NN/VENDOR_EMPLOYEE/MANAGER/ADMIN (scoped).




Rationale: Explicitly documents the permissions for all new functionalities. Forms the basis for implementation and testing of the authorization layer.
Acceptance Criteria:
Authorization middleware/logic accurately implements these permission checks for corresponding API endpoints.
Unit and integration tests verify that users with different roles and attributes can/cannot perform specific actions according to this matrix.
Attempts to perform unauthorized actions result in HTTP 403 Forbidden responses.


Priority: Must Have
Standard/Reference: RBAC, ABAC, OWASP A01:2021-Broken Access Control
REQ-AUTHZ-003
Requirement Type: Security, Access Control
Description: Authorization checks MUST be performed on the server-side within the API layer. The client application MUST NOT be relied upon to enforce authorization rules, only to potentially hide UI elements based on user role/permissions provided by the backend.
Rationale: Prevents malicious users from bypassing client-side UI restrictions and directly calling APIs they shouldn't have access to. Security enforcement must happen at the resource server.
Acceptance Criteria:
All API endpoints implementing actions or accessing sensitive data have server-side authorization checks.
Security testing confirms that API calls are rejected based on server-side rules, even if crafted manually (e.g., using tools like Postman or curl).


Priority: Must Have
Standard/Reference: OWASP A01:2021-Broken Access Control, Secure Design Principles

Module: Core Petition Template Structure
REQ-PTMPL-001
Requirement Type: Data
Description: The system MUST persist petition template data in a PetitionTemplates table. Each record MUST include:
id (Primary Key, UUID recommended)
name (TEXT, Template name, Unique, NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich description of the petition template.
petition_type_id (UUID, FK to PetitionTemplateTypes.id, NOT NULL)
status (Enum: 'DRAFT', 'PUBLISHED', 'ARCHIVED', default: 'DRAFT', NOT NULL)
version (Integer, default: 1, NOT NULL)
eligibility_condition (TEXT, Nullable) - Stores the logical expression for eligibility.
filing_instructions_content_id (UUID, Nullable FK to ContentBlocks.id) - For self-filing instructions.
created_by_user_id (UUID, FK to Users.id, NOT NULL)
updated_by_user_id (UUID, FK to Users.id, NOT NULL)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Rationale: Defines the main template entity. Uses ContentBlocks for rich descriptions. root_form_definition_id removed as root form fields are directly linked.
Acceptance Criteria:
Database schema includes PetitionTemplates table.
Admins can associate a ContentBlock for the description.


Priority: Must Have
Standard/Reference: Data Modeling
REQ-PTMPL-002
Requirement Type: Data
Description: The system MUST have lookup tables for PetitionTemplateTypes (e.g., 'USCIS_VISA', 'OTHER_GOVT_APP') and PetitionTemplateTags (e.g., 'EMPLOYMENT_BASED', 'FAMILY_BASED'). These tables are managed by Developers or designated super-admins, not regular NN Admins via the UI. A many-to-many relationship MUST exist between PetitionTemplates and PetitionTemplateTags via an association table (PetitionTemplateTagAssignments).
Rationale: Provides controlled vocabularies for classifying templates. Allows assignment of multiple tags.
Acceptance Criteria:
PetitionTemplateTypes table exists with id, name, description.
PetitionTemplateTags table exists with id, name, description.
PetitionTemplateTagAssignments table exists linking the Petition template's id and the Tag's id.
Mechanism for managing Types/Tags (e.g., DB seeds, internal admin interface) is defined separately.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-003
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for NN Admins (NN_ADMIN) to manage the lifecycle of Petition Templates:
POST /v1/petition-templates: Create a new template (initial state 'DRAFT'). Requires name, petition_type_id, allows optional description, tag_ids.
GET /v1/petition-templates: List existing templates. Supports filtering by status, petition_type_id, tag_ids.
GET /v1/petition-templates/{templateId}: Retrieve details of a specific template (including its associated components like tabs, plans, criteria - potentially via nested data or separate calls).
PATCH /v1/petition-templates/{templateId}: Update basic template details (name, description, tag_ids). Can only update templates in 'DRAFT' status. Increment version.
POST /v1/petition-templates/{templateId}/publish: Change status from 'DRAFT' to 'PUBLISHED'. Performs validation checks (REQ-PTMPL-VALIDATE-001).
POST /v1/petition-templates/{templateId}/archive: Change status from 'PUBLISHED' to 'ARCHIVED'. Prevents new petitions from being created based on it.
POST /v1/petition-templates/{templateId}/revert: (Optional: Consider versioning implications) Revert an 'ARCHIVED' template back to 'DRAFT' or create a new draft based on it.
DELETE /v1/petition-templates/{templateId}: Delete a template (only if in 'DRAFT' status).


Rationale: Provides full CRUD and lifecycle management capabilities for petition templates exclusively for NN Admins.
Acceptance Criteria:
Specified endpoints exist and function as described.
Only NN Admins can access these endpoints.
Status transitions are correctly enforced.
Updating triggers version increment.
Deletion constraints are enforced.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, OWASP A01:2021-Broken Access Control, REST Principles, OAS 3.x

Module: Petition Template Tabs
REQ-PTMPL-TAB-001
Requirement Type: Data
Description: The system MUST persist template tab definitions in a PetitionTemplateTabs table. Each record MUST include:
id (Primary Key, UUID recommended)
template_id (UUID, FK to PetitionTemplates.id, NOT NULL)
title (TEXT, Tab title, NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich description for the tab.
display_order (Integer, NOT NULL, unique per template_id)
is_required (Boolean, default: true, NOT NULL)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Rationale: Defines tab structure. Uses ContentBlocks for rich descriptions.
Acceptance Criteria: Database schema includes PetitionTemplateTabs. Admins can associate ContentBlock for description.
Priority: Must Have
Standard/Reference: Data Modeling


REQ-PTMPL-TAB-002
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for NN Admins (NN_ADMIN) to manage tabs within a 'DRAFT' Petition Template:
POST /v1/petition-templates/{templateId}/tabs: Add a new tab. Requires title, order, allows description, is_required.
GET /v1/petition-templates/{templateId}/tabs: List tabs for a template, ordered by order.
PATCH /v1/petition-templates/{templateId}/tabs/{tabId}: Update an existing tab (title, description, order, is_required). Re-ordering might require adjustments to other tabs' order values.
DELETE /v1/petition-templates/{templateId}/tabs/{tabId}: Remove a tab. Must cascade delete associated document requirements (TabDocuments).


Rationale: Allows NN Admins to define and modify the tab structure of a template.
Acceptance Criteria:
Specified endpoints exist and function as described.
Only NN Admins can access these endpoints for 'DRAFT' templates.
Endpoints correctly manage tab creation, updates (including order), and deletion.
Deletion correctly handles dependencies.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, REST Principles, OAS 3.x

Module: Petition Template Criteria
REQ-PTMPL-CRIT-001
Requirement Type: Data
Description: The system MUST persist template eligibility criteria questions by linking a Petition Template to specific DataPoints intended for eligibility checking. This link MUST be stored in a PetitionTemplateCriteriaLinks table. Each record MUST include:
id (Primary Key)
template_id (FK to PetitionTemplates, NOT NULL)
data_point_id (FK to DataPoints, NOT NULL) - The data point representing the question.
order (Integer, display order of questions)


Rationale: Defines the questions asked for eligibility using the central DataPoints definitions (leveraging DataPoints.question_text, data_type, options).
Acceptance Criteria:
Database schema includes PetitionTemplateCriteriaLinks table.
Ensures criteria questions are based on standardized, reusable data points.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-CRIT-002
Requirement Type: Data
Description: The system MUST store the overall eligibility condition logic for a template as a field (eligibility_condition TEXT) within the PetitionTemplates table. This string MUST represent the logical expression using DataPoints.system_name as variables (e.g., "(client.years_experience > 10 AND client.has_degree == TRUE) OR client.special_case == TRUE").
Rationale: Stores the rule used to evaluate answers, referencing centrally defined data points via their unique system names.
Acceptance Criteria:
PetitionTemplates table includes eligibility_condition field.
Format/syntax allowed in the condition string is defined. Variables MUST match DataPoints.system_name.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-CRIT-003
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for NN Admins (NN_ADMIN) to manage criteria questions (by linking DataPoints) and the condition for a 'DRAFT' Petition Template:
POST /v1/petition-templates/{templateId}/criteria/links: Link a DataPoint as a criteria question. Requires data_point_id, order.
GET /v1/petition-templates/{templateId}/criteria/links: List linked Data Points (criteria questions) for the template, ordered by order. Returns relevant DataPoints details (question text, type, etc.).
DELETE /v1/petition-templates/{templateId}/criteria/links/{linkId}: Unlink a Data Point. Must ensure the DataPoints.system_name is removed/handled in the main condition if it exists.
PUT /v1/petition-templates/{templateId}/criteria/condition: Set or update the eligibility_condition string. Backend MUST validate syntax and ensure all variable names used exist as DataPoints.system_name.
GET /v1/petition-templates/{templateId}/criteria/condition: Retrieve the current eligibility_condition string.


Rationale: Allows NN Admins to define the eligibility screening process using centrally defined Data Points.
Acceptance Criteria:
Specified endpoints exist and function. Only NN Admins access for 'DRAFT' templates.
Condition string syntax/variable validation uses DataPoints.
Endpoints and schemas documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, REST Principles, OAS 3.x
REQ-PTMPL-CRIT-004
Requirement Type: Functional, Client-Side Logic, API
Description: The backend MUST provide an endpoint (POST /v1/petition-templates/{templateId}/check-eligibility) to evaluate client-provided answers against the template's criteria questions and condition.
Input: Answers keyed by variable_name.
Output: JSON response { "is_eligible": boolean, "message": "Optional feedback message" }.
The client application, upon receiving the response, MUST display the result. If is_eligible is false, the client MUST display a message like "Based on your answers, this petition may not be suitable for you as the minimum criteria appear unmet. You can choose to proceed with creating the petition, but it is not recommended." The client MUST allow the user to proceed to plan selection even if is_eligible is false.


Rationale: Implements the eligibility check but allows clients to override the recommendation and continue at their own risk, as requested.
Acceptance Criteria:
POST /v1/petition-templates/{templateId}/check-eligibility endpoint exists, takes answers, evaluates condition, returns eligibility status and optional message. Documented in OAS.
Client displays the appropriate message based on the is_eligible flag.  (POST /v1/petition-templates/{templateId}/check-eligibility returns { "is_eligible": boolean, "message": "..." }. Client displays message but allows proceeding.)
Client UI allows proceeding regardless of the eligibility result.


Priority: Must Have
Standard/Reference: -

Module: Petition Template Plans & Benefits
REQ-PTMPL-BEN-001
Requirement Type: Data
Description: The system MUST have a Benefits table. Each record MUST include:
id (Primary Key, UUID recommended)
name (TEXT, Benefit name, Unique, NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich description of the benefit.
cost (DECIMAL, Cost if purchased as a standalone add-on, NOT NULL)
is_task_triggering (Boolean, default: false, NOT NULL)
managed_by (Enum: 'DEVELOPER', 'ADMIN', NOT NULL)


Rationale: Defines benefits. Uses ContentBlocks for rich descriptions. triggered_task_model_id moved to BenefitTriggeredTaskModels.
Acceptance Criteria: Schema exists. Admins/Devs can associate ContentBlock for description.
Priority: Must Have
Standard/Reference: Data Modeling


REQ-PTMPL-BEN-TASKLINK-001 (NEW - Linking Benefits to Task Models)
Requirement Type: Data
Description: If a Benefit has is_task_triggering set to true, there MUST be a way to associate it with one or more specific TaskModels that will be instantiated when the benefit is acquired. This is managed via a BenefitTriggeredTaskModels table:
id (Primary Key, UUID)
benefit_id (FK to Benefits.id, NOT NULL)
task_model_id (FK to TaskModels.id, NOT NULL)
notes (TEXT, Optional, e.g., "Primary task for this benefit")


Rationale: Explicitly defines which Task Model(s) are created when a task-triggering benefit is activated for a petition instance. Addresses the "Benefits translate to tasks" user note.
Acceptance Criteria:
Database schema includes BenefitTriggeredTaskModels table.
Admin interface allows linking task-triggering benefits to specific task models.
A benefit can potentially trigger multiple distinct task models.


Priority: Must Have
Standard/Reference: Data Modeling
REQ-PTMPL-PLAN-INCLUDED-BEN-001
Requirement Type: Data
Description: A many-to-many relationship MUST exist between PetitionTemplatePlans and Benefits to specify which benefits are included as part of each plan. This MUST be stored in a PlanIncludedBenefits join table. Each record MUST include:
id (Primary Key, UUID recommended)
plan_id (FK to PetitionTemplatePlans.id, NOT NULL)
benefit_id (FK to Benefits.id, NOT NULL)
Unique constraint on (plan_id, benefit_id).


Rationale: Explicitly defines which benefits are intrinsically part of each plan.
Acceptance Criteria: Database schema exists as specified.
Priority: Must Have
Standard/Reference: Data Modeling


REQ-PTMPL-TEMPLATE-AVAILABLE-ADDONS-001
Requirement Type: Data
Description: A many-to-many relationship MUST exist between PetitionTemplates and Benefits to specify which benefits are available to be purchased as add-ons for any petition created from that template. This MUST be stored in a PetitionTemplateAvailableAddons join table. Each record MUST include:
id (Primary Key, UUID recommended)
template_id (FK to PetitionTemplates.id, NOT NULL)
benefit_id (FK to Benefits.id, NOT NULL)
Unique constraint on (template_id, benefit_id).


Rationale: Defines the catalog of all possible add-on benefits for a specific petition template. The actual purchasable list for a client depends on what's already in their chosen plan.
Acceptance Criteria: Database schema exists as specified.
Priority: Must Have
Standard/Reference: Data Modeling
REQ-PTMPL-PLAN-001
Requirement Type: Data
Description: The system MUST persist template plan definitions in a PetitionTemplatePlans table. Each record MUST include:
id (Primary Key, UUID recommended)
template_id (UUID, FK to PetitionTemplates.id, NOT NULL)
name (TEXT, Plan name, NOT NULL, unique per template_id)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich description of the plan.
cost (DECIMAL, Cost for selecting this plan, NOT NULL)
is_free (Boolean, generated as (cost == 0), NOT NULL)
display_order (Integer, NOT NULL)
terms_and_conditions_id (UUID, Nullable FK to TermsAndConditions.id)
created_at, updated_at


Rationale: Defines service tiers. Uses ContentBlocks for rich descriptions.
Acceptance Criteria: Schema exists. Admins can associate ContentBlock for description.
Priority: Must Have
Standard/Reference: Data Modeling
REQ-PTMPL-PLAN-002
Requirement Type: Data
Description: A many-to-many relationship MUST exist between PetitionTemplatePlans and Benefits via an association table (PlanBenefits). This table links specific benefits included within each plan.
plan_benefit_id (Primary Key)
plan_id (FK to PetitionTemplatePlans)
benefit_id (FK to Benefits)


Rationale: Explicitly defines which benefits are part of each plan.
Acceptance Criteria:
Database schema includes PlanBenefits association table with specified fields and constraints (unique key on plan_id, benefit_id).


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-PLAN-003
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for NN Admins (NN_ADMIN) to manage plans and benefits associations within a 'DRAFT' Petition Template:
Plan CRUD:
POST /v1/petition-templates/{templateId}/plans: Create a new plan. Requires name, description, cost, display_order. Optionally terms_and_conditions_id.
GET /v1/petition-templates/{templateId}/plans: List plans for a template. Response SHOULD include details of their included benefits.
GET /v1/petition-templates/{templateId}/plans/{planId}: Get details of a specific plan, including its included benefits.
PATCH /v1/petition-templates/{templateId}/plans/{planId}: Update plan details (name, description, cost, display_order, terms_and_conditions_id).
DELETE /v1/petition-templates/{templateId}/plans/{planId}: Remove a plan. Must cascade delete associated PlanIncludedBenefits and plan-specific graph definitions (PlanTaskGraphNodes, PlanTaskGraphEdges). Cannot delete the last plan.


Managing Included Benefits for a Plan:
POST /v1/petition-templates/{templateId}/plans/{planId}/included-benefits: Associate an existing Benefit with the specified plan (creates record in PlanIncludedBenefits). Request: {"benefit_id": "..."}.
DELETE /v1/petition-templates/{templateId}/plans/{planId}/included-benefits/{benefitId}: Disassociate an included Benefit from the plan.


Managing Available Add-ons for a Template:
POST /v1/petition-templates/{templateId}/available-addons: Mark a Benefit as an available add-on for this template (creates record in PetitionTemplateAvailableAddons). Request: {"benefit_id": "..."}.
GET /v1/petition-templates/{templateId}/available-addons: List benefits configured as available add-ons for this template.
DELETE /v1/petition-templates/{templateId}/available-addons/{benefitId}: Remove a benefit from the list of available add-ons for this template.




Rationale: Provides comprehensive API for admins to define plan structures, what benefits are included in them, and what benefits can be separately purchased as add-ons for the entire template. Addresses user note.
Acceptance Criteria:
Specified endpoints exist and function correctly.
Authorization restricts access to NN_ADMIN for 'DRAFT' templates.
Cascade deletion rules are implemented for plan deletion.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, REST Principles, Data Integrity, OAS 3.x
REQ-PTMPL-PLAN-004
Requirement Type: Functional, Constraint
Description: Every Petition Template MUST have at least one plan defined before it can be 'PUBLISHED'. At least one of these plans SHOULD typically be a 'Free' plan (cost == 0), although this is not a strict system constraint.
Rationale: Ensures clients have at least one option to choose from when starting a petition. Reflects business model description.
Acceptance Criteria:
Validation check during POST /v1/petition-templates/{templateId}/publish verifies at least one plan exists.
Publish operation fails with an error if no plans are defined.


Priority: Must Have
Standard/Reference: Business Logic Constraint

Module: Terms and Conditions Management 
REQ-PETI-TNC-001
Requirement Type: Functional, API, Legal
Description: Before a client can finalize the payment for a petition (plan + add-ons), they MUST explicitly accept the Terms and Conditions associated with the selected PetitionTemplatePlan (referenced by PetitionTemplatePlans.terms_and_conditions_id).
The client application MUST display the content of the applicable TermsAndConditions document.
The client MUST actively indicate acceptance (e.g., via a checkbox).
The API endpoint that processes the final order/initiates payment (e.g., POST /v1/orders/checkout or similar, see REQ-ADDON-002) MUST receive an indicator of this acceptance.
The system MUST log this acceptance event, storing user_id, plan_id, terms_and_conditions_id (and its version/effective_date), and timestamp_of_acceptance.


Rationale: Ensures legal compliance by obtaining and recording client agreement to specific terms for the services purchased. This aligns with the "Payment & Terms Acceptance Screen" mockup.
Acceptance Criteria:
Client UI displays relevant T&C content and provides a clear mechanism for acceptance.
Backend API receives confirmation of T&C acceptance as part of the order finalization/payment initiation.
T&C acceptance is securely logged with all required details for auditing.
Payment processing is blocked if T&C are not accepted.


Priority: Must Have
Standard/Reference: Legal Compliance, E-commerce Best Practices
REQ-PETI-ORDER-001
Requirement Type: Functional, API
Description: An API endpoint (e.g., POST /v1/orders/checkout) MUST exist to finalize a client's order for a new petition. This endpoint is called after plan selection, add-on selection (if any), and T&C acceptance (REQ-PETI-TNC-001). The request MUST include:
template_id
plan_id
Array of selected benefit_ids for purchased add-ons (if any).
Indicator of T&C acceptance.
Payment method details (or token from payment gateway if using client-side tokenization).
This endpoint will:
Calculate the total cost (plan cost + sum of selected add-on costs).
Process payment via the integrated payment gateway.
If payment is successful:
a. Trigger the creation of the PetitionInstance and its initial Root Form Task (as per REQ-PETI-001).
b. Record purchased benefits in PetitionInstanceBenefits (as per REQ-ADDON-001).
c. Trigger instantiation of any benefit-specific tasks (as per REQ-PETI-003 / REQ-PTMPL-BEN-TASKLINK-001).
Return a success response including the petition_instance_id and the task_instance_id of the Root Form task, or an error if payment/creation fails.


Rationale: Provides a single transactional endpoint to confirm the client's choices, process payment, and initiate the creation of all necessary petition-related records and initial tasks. Aligns with "Complete Your Order" screen mockup.
Acceptance Criteria:
POST /v1/orders/checkout endpoint exists, is authenticated and authorized for CLIENT role.
Calculates total cost accurately.
Securely processes payment via the payment gateway.
Upon successful payment, all subsequent actions (PetitionInstance creation, Root Form Task creation, benefit recording, benefit task creation) are triggered and completed successfully.
T&C acceptance is verified before proceeding.
Returns appropriate success or error response.
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: E-commerce Checkout Flow, Payment Gateway Integration, REST Principles, OAS 3.x
REQ-TNC-001
Requirement Type: Data, Functional
Description: The system MUST allow for storing and managing multiple versions of Terms and Conditions documents in a TermsAndConditions table. Each record MUST include:
id (Primary Key, UUID recommended)
title (TEXT, e.g., "Standard Plan Terms v1.2", "Vendor Agreement v2.0", NOT NULL)
content (TEXT, supporting rich text or Markdown for the full T&C document, NOT NULL)
version (VARCHAR or Integer, e.g., "1.2", NOT NULL)
effective_date (DATE, NOT NULL)
is_active (Boolean, default: true, NOT NULL) - Only active T&Cs can be assigned to new plans.
created_by_user_id (UUID, FK to Users.id)
created_at (TIMESTAMP WITH TIME ZONE)


Rationale: Provides a central repository for T&C documents that can be versioned and associated with specific petition template plans, as required by REQ-PTMPL-PLAN-001 and seen in payment screen mockups.
Acceptance Criteria:
Database schema includes TermsAndConditions table with specified fields.
NN Admins can CRUD T&C documents via a dedicated internal API/interface.


Priority: Must Have
Standard/Reference: Legal Compliance, Data Modeling

Module: Central Data Point Definitions
REQ-DP-001
Requirement Type: Data
Description: The system MUST have a central DataPoints table serving as the single source of truth for all potential pieces of data used as inputs or outputs. Each record MUST include:
id (Primary Key, UUID recommended)
system_name (TEXT, Unique, Indexed, NOT NULL, e.g., 'client.passport.expiry_date', 'doc.birth_certificate.file_ref')
display_name (TEXT, NOT NULL, e.g., "Passport Expiry Date")
question_text (TEXT, Nullable, e.g., "What is your passport's expiry date?") - User-facing question for direct input.
data_type (Enum: 'STRING', 'TEXT_BLOCK', 'NUMBER_INTEGER', 'NUMBER_DECIMAL', 'DATE', 'BOOLEAN', 'FILE_REFERENCE', 'ARRAY_OF_FILES', 'JSON_OBJECT', 'EMAIL', 'PHONE_NUMBER', 'URL', 'SINGLE_CHOICE', 'MULTIPLE_CHOICE', NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Optional link to a rich content block for detailed help text/guidance related to this data point, displayed in UIs.
is_pii (Boolean, default: false, NOT NULL) - Indicates if this data point typically contains Personally Identifiable Information.
validation_rules (JSONB, Nullable) - Stores structured validation rules (e.g., regex, min/max length/value, required if applicable in a specific context).
options_list_id (UUID, Nullable FK to OptionLists.id) - Used if data_type is 'SINGLE_CHOICE' or 'MULTIPLE_CHOICE'.
managed_by (Enum: 'DEVELOPER', 'ADMIN', NOT NULL)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Rationale: Centralizes data element definitions. description_content_id allows rich help text. validation_rules centralizes validation logic. options_list_id enables reusable choice sets.
Acceptance Criteria:
Database schema includes DataPoints table.
Enum for data_type includes 'SINGLE_CHOICE', 'MULTIPLE_CHOICE'.
validation_rules JSON schema is defined.
Process for managing DataPoints exists.


Priority: Must Have
Standard/Reference: Data Modeling, Single Source of Truth Principle
REQ-DP-OPT-001 (NEW - Option Lists for DataPoints)
Requirement Type: Data
Description: To support DataPoints of data_type 'SINGLE_CHOICE' or 'MULTIPLE_CHOICE', the system MUST have tables for managing reusable lists of options:
OptionLists Table:
id (Primary Key, UUID recommended)
name (TEXT, Unique, human-readable name for the list, e.g., "Gender Options", "Country List", NOT NULL)
description (TEXT, Nullable)
managed_by (Enum: 'DEVELOPER', 'ADMIN', NOT NULL)
created_at, updated_at


OptionListItems Table:
id (Primary Key, UUID recommended)
option_list_id (UUID, FK to OptionLists.id, NOT NULL)
item_value (TEXT, NOT NULL, the actual value stored in the database)
item_label (TEXT, NOT NULL, the user-facing label for display)
display_order (Integer, default: 0, NOT NULL)
is_active (Boolean, default: true, NOT NULL)
Unique constraint on (option_list_id, item_value).
Unique constraint on (option_list_id, item_label).




Rationale: Provides a centralized, manageable way to define and reuse sets of choices for dropdowns, radio buttons, or checkbox groups linked to DataPoints.
Acceptance Criteria:
Database schema includes OptionLists and OptionListItems tables with specified fields and constraints.
A process (DB seeds or Admin UI) exists for managing these lists and items.
DataPoints.options_list_id correctly references OptionLists.id.


Priority: Must Have
Standard/Reference: Data Modeling, UI/UX Best Practices for Forms

Module: Document Types & Presets
REQ-DOCTYPE-001
Requirement Type: Data
Description: The system MUST have a DocumentTypes table defining the main categories of documents. Each record MUST include:
id (Primary Key, UUID recommended)
name (Main type name, e.g., "Simple Document Scan", "List of Documents", "Generated Document", Unique)
description (Text description)
managed_by (Enum: 'DEVELOPER', default: 'DEVELOPER') - Indicates these are centrally managed.


Rationale: Establishes broad categories for document handling logic.
Acceptance Criteria:
Database schema includes DocumentTypes table with specified fields.
Initial set of types ("Simple Document Scan", "List of Documents", "Generated Document") are seeded.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-DOCTYPE-002
Requirement Type: Data
Description: The system MUST have a DocumentTypePresets table defining specific examples or variations within a main Document Type. Each record MUST include:
id (Primary Key, UUID recommended)
document_type_id (Foreign Key referencing DocumentTypes, NOT NULL)
preset_name (Specific preset name, e.g., "Passport", "Birth Certificate", "Professional Plan", "I-140 Form", Unique)
description (Text description)
requires_client_upload (Boolean, indicates if client typically uploads a file for this preset)
is_list (Boolean, indicates if this preset represents a list/multiple documents, linked to "List of Documents" type)
is_generated (Boolean, indicates if this preset is typically generated by NN/Vendor/AI, linked to "Generated Document" type)
managed_by (Enum: 'DEVELOPER', default: 'DEVELOPER') - Indicates these are centrally managed.


Rationale: Provides specific, reusable document definitions used throughout the template configuration. Clarifies the expected nature of the document (uploaded, list, generated).
Acceptance Criteria:
Database schema includes DocumentTypePresets table with specified fields and constraints.
Initial set of presets (Passport, Birth Certificate, Professional Plan, etc.) are seeded, linked to appropriate DocumentTypes.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-DOCTYPE-003
Requirement Type: Data
Description: The system MUST link Document Type Presets to the central Data Points they typically involve using a DocumentPresetDataPointLinks table. This defines the standard inputs/outputs associated with a document type. Each record MUST include:
id (Primary Key)
preset_id (FK to DocumentTypePresets, NOT NULL)
data_point_id (FK to DataPoints, NOT NULL)
direction (Enum: 'INPUT', 'OUTPUT') - Indicates if this data point is typically an input or output for this preset.
is_primary_output (Boolean, default: false) - If direction is 'OUTPUT', indicates if this is the main document file/data itself (e.g., the generated PDF, the scanned passport file). A preset should have typically one primary output.


Rationale: Links document presets to their standard data elements defined centrally in DataPoints, clarifying the typical I/O relationship. Replaces the previous DocumentPresetDataPoints. Task models will specify their exact requirements.
Acceptance Criteria:
Database schema includes DocumentPresetDataPointLinks table.
Links are established for initial presets (e.g., Passport preset linked to DataPoints for passport number, expiry date, file reference output, etc.).


Priority: Must Have
Standard/Reference: Data Modeling Best Practices

Module: Task Models
REQ-TASKM-001
Requirement Type: Data
Description: The system MUST persist task model definitions in a TaskModels table. Each record MUST include:
id (Primary Key, UUID recommended)
name (TEXT, Task model name, Unique, NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich overall description/instructions for the task, visible to clients/users.
document_type_preset_id (UUID, FK to DocumentTypePresets.id, NOT NULL)
cost (DECIMAL, additional cost for this model, NOT NULL)
requires_lawyer_assignment (Boolean, default: false, NOT NULL)
managed_by (Enum: 'DEVELOPER', 'ADMIN', NOT NULL)
created_at, updated_at


Rationale: Defines task templates. Uses ContentBlocks for rich task descriptions.
Acceptance Criteria: Schema exists. Admins/Devs can associate ContentBlock for description.
Priority: Must Have
Standard/Reference: Data Modeling
REQ-TASKM-002
Requirement Type: Data
Description: The system MUST persist the steps associated with each Task Model in a TaskModelSteps table. Each record MUST include:
id (Primary Key, UUID recommended)
task_model_id (UUID, FK to TaskModels.id, NOT NULL)
step_number (Integer, NOT NULL, defining order within model)
name (TEXT, Step name/title, NOT NULL)
description_content_id (UUID, Nullable FK to ContentBlocks.id) - Rich instructions specific to this step.
step_type (Enum: 'CLIENT_INPUT', 'VALIDATION_AUTO', 'VALIDATION_MANUAL', 'OUTPUT_GENERATION', 'OUTPUT_ASSIGNMENT', NOT NULL)
assigned_role (Enum: 'CLIENT', 'EMPLOYEE', 'MANAGER', 'LAWYER', 'AI', 'SYSTEM', NOT NULL)
deadline_duration_days (Integer, Nullable)
success_target_step_number (Integer, NOT NULL)
failure_target_step_number (Integer, Nullable)
ai_process_id (UUID, Nullable FK to AIProcesses.id)


Rationale: Defines task workflow steps. Uses ContentBlocks for rich step-specific instructions.
Acceptance Criteria: Schema exists. Admins/Devs can associate ContentBlock for step descriptions.
Priority: Must Have
Standard/Reference: Data Modeling
REQ-TASKM-003
Requirement Type: Data
Description: The system MUST define the specific data points that each Task Model requires as input OR produces as output using a TaskModelDataPointLinks table. This allows task models to specify exact I/O needs, including extra outputs. Each record MUST include:
id (Primary Key)
task_model_id (FK to TaskModels, NOT NULL)
data_point_id (FK to DataPoints, NOT NULL)
direction (Enum: 'INPUT', 'OUTPUT') - Does this model REQUIRE this input or PRODUCE this output?
is_required_input (Boolean, nullable) - If direction is 'INPUT', is it mandatory for this specific model?
is_separate_request (Boolean, nullable) - If direction is 'INPUT', collect within this task?
is_evidence_based (Boolean, nullable) - If direction is 'INPUT', must it come from another task's output?


Rationale: Provides a single mechanism for Task Models to declare their precise data dependencies (inputs) and deliverables (outputs), referencing the central DataPoints definitions. Allows different models for the same preset to have varying I/O. Replaces TaskModelInputs.
Acceptance Criteria:
Database schema includes TaskModelDataPointLinks table.
Allows linking task models to specific Data Points for both input and output.
Input-specific flags (is_required_input, is_separate_request, is_evidence_based) are defined.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-TASKM-004
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for managing TaskModels. Endpoints for managing associated data points (TaskModelDataPointLinks) MUST be provided:
GET /v1/task-models/{modelId}/datapoints: List associated input and output data points for the model.
POST /v1/task-models/{modelId}/datapoints: Associate a DataPoint with the model (specifying direction and input-specific flags). Requires data_point_id, direction, etc.
PATCH /v1/task-models/{modelId}/datapoints/{linkId}: Update the details of an association (e.g., change is_required_input).
DELETE /v1/task-models/{modelId}/datapoints/{linkId}: Remove an association.
Other Task Model endpoints (POST, GET, PATCH, DELETE) remain as previously defined. Step management APIs also remain.


Rationale: Provides API interface for defining the specific inputs and outputs of each task model.
Acceptance Criteria:
Specified endpoints exist and function.
API payloads correctly handle TaskModelDataPointLinks definition.
Authorization appropriately restricts access.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, REST Principles, OAS 3.x

Module: Petition Template Document & Task Configuration
REQ-PTMPL-DOC-001
Requirement Type: Data
Description: The system MUST persist the association between template tabs and document presets in PetitionTemplateTabDocuments. Each record MUST include:
id (Primary Key)
tab_id (FK to PetitionTemplateTabs, NOT NULL)
document_type_preset_id (FK to DocumentTypePresets, NOT NULL)
is_required (Boolean, default: true) - Is this document generally mandatory for the petition (can still be invalidated by condition)?
invalidation_condition (TEXT, nullable) - Condition string evaluated after root form submission. If true, the corresponding Task Instance is marked is_invalidated. Condition string using DataPoints.system_name as variables. Can apply to both required and optional documents.
multiplicity_condition (TEXT, nullable) - Condition string evaluated after root form submission. Determines the number of instances/documents required for the task (e.g., returns numberOfChildren). If null or evaluates non-numerically, defaults to 1. Condition string using DataPoints.system_name as variables.


Rationale: Defines what documents potentially belong in each tab, whether they are fundamentally required or optional, and the conditions (based on root form data) that determine their final validity and quantity for a specific petition instance. Replaces condition_logic and allow_multiple.
Acceptance Criteria:
Database schema includes PetitionTemplateTabDocuments table with revised fields.
condition_logic and allow_multiple fields are removed/replaced.
Format/syntax for condition strings is defined and validated..


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-DOC-002
Requirement Type: Functional, API, Security
Description: API endpoints for managing PetitionTemplateTabDocuments (POST, GET, PATCH, DELETE under /v1/petition-templates/{templateId}/tabs/{tabId}/documents) MUST now validate that variables used in invalidation_condition and multiplicity_condition strings correspond to existing DataPoints.system_name known to the system. The admin UI should facilitate selecting available Data Points when building conditions.
Rationale: Ensures conditions use valid, defined data points.
Acceptance Criteria:
API validation checks condition variables against DataPoints.system_name.
Admin UI assists in selecting valid data points for conditions.
Endpoints and schemas documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, API Validation, OAS 3.x


REQ-PTMPL-TASKASSOC-001
Requirement Type: Data
Description: The system MUST persist the association between a specific document requirement (within a tab) and the specific Task Model chosen to fulfill it for a specific Plan, in a PlanDocumentTaskModels table. Each record MUST include:
id (Primary Key)
plan_id (FK to PetitionTemplatePlans, NOT NULL)
tab_document_id (FK to PetitionTemplateTabDocuments, NOT NULL) - Links to the specific document requirement in a tab.
task_model_id (FK to TaskModels, NOT NULL) - The chosen task model for this doc, under this plan.


Rationale: This is the crucial link defining how a document requirement is met for each service plan (e.g., Free plan uses "Basic Upload", Premium plan uses "Attorney Assisted Drafting" for the same required document).
Acceptance Criteria:
Database schema includes PlanDocumentTaskModels table.
A unique constraint MUST exist on (plan_id, tab_document_id) to ensure only one task model is assigned per document requirement per plan.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-PTMPL-TASKASSOC-002
Requirement Type: Functional, API, Security
Description: API endpoints MUST exist for NN Admins (NN_ADMIN) to associate Task Models with document requirements for each plan within a 'DRAFT' Petition Template:
PUT /v1/petition-templates/{templateId}/plans/{planId}/document-task-models: (Bulk endpoint recommended) Accepts a list of mappings [{ "tab_document_id": "...", "task_model_id": "..." }, ...]. This assigns or updates the Task Model for each document requirement under the specified plan. The backend MUST validate that the chosen task_model_id corresponds to the document_type_preset_id defined in the referenced tab_document_id.
GET /v1/petition-templates/{templateId}/plans/{planId}/document-task-models: Retrieve the current Task Model assignments for all document requirements under the specified plan.


Rationale: Allows NN Admins to configure the specific tasks that will be generated for clients based on their chosen plan.
Acceptance Criteria:
Specified endpoints exist and function as described.
Only NN Admins can access for 'DRAFT' templates.
Validation ensures the Task Model matches the required Document Type Preset.
Endpoints correctly manage the PlanDocumentTaskModels associations.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, REST Principles, OAS 3.x
REQ-PTMPL-VALIDATE-001
Requirement Type: Functional, Constraint, Server-Side Logic, Admin UI Interaction
Description: Before a Petition Template can be 'PUBLISHED' (via POST /v1/petition-templates/{templateId}/publish), or when an admin explicitly triggers "Save & Validate" for a 'DRAFT' template, the system MUST perform comprehensive validation:
Basic Template Checks:
name and petition_type_id MUST be present.
At least one PetitionTemplatePlan MUST be defined (REQ-PTMPL-PLAN-004).


Root Form Definition Check:
The unified Root Form definition (PetitionTemplateRootFormFields) MUST have been successfully calculated (REQ-GRAPH-ROOTFORM-CALC-001).
All DataPoints referenced in this root form definition MUST exist and be valid.


Condition Validation (across all PetitionTemplateTabDocuments):
invalidation_condition and multiplicity_condition strings (if present) MUST have valid syntax.
All DataPoints.system_name variables used in these conditions MUST correspond to DataPoints included in the Unified Root Form definition or be derivable as outputs from tasks that would precede the condition's evaluation context (this latter check is complex and might be simplified to only allow root form variables in these specific conditions). Decision: For invalidation_condition and multiplicity_condition on PetitionTemplateTabDocuments, variables MUST come from the Unified Root Form.


Per-Plan Configuration & Graph Validation (Iterate for each Plan of the Template):
a. Task Model Assignments: Every PetitionTemplateTabDocument that is is_required=true (or potentially active based on non-root-form conditions, if any) MUST have a TaskModel assigned to it for the current plan via PlanDocumentTaskModels. The assigned TaskModel.document_type_preset_id MUST match the PetitionTemplateTabDocument.document_type_preset_id.
b. Graph Calculation: The potential task graph for this plan (nodes and edges) MUST be successfully calculated and stored as per REQ-GRAPH-CALC-001 (PlanTaskGraphNodes, PlanTaskGraphEdges).
c. Dependency Resolution (Unconnected Evidence-Based Inputs):
i. Identify all required (is_required_input=true), evidence-based (is_evidence_based=true) INPUT DataPoints for all PlanTaskGraphNodes in this plan's graph.
ii. Verify that each such input DataPoint has a corresponding OUTPUT DataPoint (matching data_point_id) produced by another PlanTaskGraphNode in the same plan (via a defined PlanTaskGraphEdge) or by a DataPoint collected in the Unified Root Form.
iii. If Unconnected Inputs Exist:
* The overall validation fails. The template cannot be published.
* The system MUST provide feedback to the NN Admin listing the specific unconnected INPUT DataPoints and for which plan(s) they are problematic.
* The admin UI MUST then guide the admin to resolve these by adding "Admin-Added Root Tasks" for this plan: Select a DocumentTypePreset that can produce the missing output, then select a compatible TaskModel. This creates a new PlanTaskGraphNode (source_type 'ADMIN_ADDED_ROOT_TASK') for this specific plan.
* The graph calculation (4b) and dependency resolution (4c) for this plan MUST be re-run. This process is iterative until all required evidence-based inputs for this plan are connected.
Final Check: The template is considered valid for publishing only if all above checks pass for the template itself and for all its associated plans.


Rationale: Ensures published templates are complete, structurally sound, logically consistent, and that all data dependencies within every plan's workflow are resolvable. Provides an interactive way for admins to fix dependency gaps. This is the primary gatekeeper for template quality.
Acceptance Criteria:
Validation logic is triggered by "Publish" or "Save & Validate" actions.
All specified checks (basic, root form, conditions, per-plan assignments, per-plan graph completeness) are executed.
If unconnected evidence-based inputs are found for any plan, the publish/validation fails, and the admin is guided through adding necessary source tasks for that plan.
A template can only be published if all checks pass successfully for the template and all its plans.
Clear error messages are provided for any validation failure.


Priority: Must Have
Standard/Reference: Data Integrity, DAG Validation, Interactive Configuration

Module: Potential Task Graph Structure
REQ-PTMPL-GRAPH-DEF-001
Requirement Type: Data, Server-Side Logic (Template Save/Validation)
Description: When a 'DRAFT' Petition Template configuration affecting tasks or plans is saved or validated, the system MUST calculate and store the potential task graph structure for each associated Plan. This calculation, performed per plan, involves:
Identifying all PetitionTemplateTabDocuments associated with the template.
For the specific planId being processed, identifying the assigned TaskModel for each document via PlanDocumentTaskModels.
Analyzing the required INPUT DataPoints and produced OUTPUT DataPoints for each assigned TaskModel via TaskModelDataPointLinks.
Determining potential dependencies within this plan's context: Task B depends on Task A if a required, evidence-based INPUT data_point_id for Task B (via its assigned Task Model) matches an OUTPUT data_point_id produced by Task A (via its assigned Task Model).
Storing this structure, explicitly linking it to the planId. This could use tables like PlanPotentialTaskNodes (linking plan_id, tab_document_id, task_model_id) and PlanPotentialTaskDependencies (linking prerequisite/dependent PlanPotentialTaskNodes based on matching data_point_id).
The PlanPotentialTaskNodes table (or equivalent) should indicate the source of the node: either derived from a PetitionTemplateTabDocument OR created as an "Admin-Added Root Task" to satisfy a previously unconnected evidence-based input (as per REQ-PTMPL-VALIDATE-001.6.d).


Rationale: Pre-calculates the specific potential workflow and dependencies for each plan, reflecting that different Task Models (and thus different I/O and dependencies) may be used. Stores this structure for validation and faster runtime instantiation. Differentiates between tasks defined as part of the main document flow vs. those added specifically to resolve missing dependencies.
Acceptance Criteria:
Process performs analysis and storage per plan.
Database schema includes tables like PlanPotentialTaskNodes, PlanPotentialTaskDependencies linked to plan_id.
Stored structure accurately reflects the plan-specific task models and dependencies based on data_point_id matching.
PlanPotentialTaskNodes structure can distinguish between these two types of source tasks.


Priority: Must Have
Standard/Reference: Graph Theory, Data Modeling
Requirement Type: Data, Server-Side Logic (Template Save/Validation)
Description: The system MUST determine and store a single unified Root Form definition for the entire Petition Template during template analysis/validation. This definition represents all data points that might need to be collected upfront, regardless of the plan chosen later. This involves:
Identifying all DataPoints referenced (by system_name) in any invalidation_condition or multiplicity_condition across all PetitionTemplateTabDocuments in the template.
For all TaskModels assigned in any Plan of the template: Identifying their required INPUT DataPoints (via TaskModelDataPointLinks) where is_separate_request is false AND is_evidence_based is false.
Consolidating the unique set of required DataPoints IDs from steps 1 & 2.
Safety Check: Verifying that every DataPoint ID identified in step 2 actually exists in the central DataPoints table. (This check is somewhat redundant if foreign keys are enforced but adds explicit validation). If any required input doesn't map to a defined DataPoint, fail validation.
Storing this definitive list of DataPoints IDs (representing the unified Root Form fields) associated with the PetitionTemplate (e.g., in a PetitionTemplateRootFormFields table linking template_id and data_point_id).


Rationale: Defines a single, comprehensive Root Form for the template by considering the upfront data needs of all conditions and all potential task models across all plans. Ensures consistency for the client initially. Uses central DataPoints for structure/text. Adds a safety check for undefined inputs.
Acceptance Criteria:
Root form determination logic correctly identifies necessary DataPoints IDs by analyzing conditions and all potential task model inputs across all plans.
Safety check verifies identified input DataPoints exist.
The consolidated list of DataPoints IDs is stored, linked to the PetitionTemplate.


Priority: Must Have
Standard/Reference: Data Modeling, Validation
REQ-PTMPL-VALIDATE-001
Requirement Type: Functional, Constraint, Server-Side Logic
Description: Before a Petition Template can be 'PUBLISHED' (POST /v1/petition-templates/{templateId}/publish), the system MUST perform comprehensive validation, including:
Basic checks (Type assigned, >=1 Plan exists).
Condition validation (Syntax OK, variables exist as DataPoints.system_name).
Root Form Input validation (Safety check in REQ-PTMPL-ROOTFORM-DEF-001 ensures all needed root form inputs are defined DataPoints).
Per-Plan Task Configuration Checks: For each Plan associated with the template:
Every required (is_required=true) PetitionTemplateTabDocument MUST have a TaskModel assigned via PlanDocumentTaskModels.
The assigned TaskModel's document_type_preset_id MUST match the document_type_preset_id of the PetitionTemplateTabDocument.


Per-Plan Graph Dependency Checks: For each Plan, based on its calculated potential task graph structure (REQ-PTMPL-GRAPH-DEF-001):
All required (is_required_input=true), evidence-based (is_evidence_based=true) INPUT DataPoints for all potential tasks in that plan's graph MUST have a corresponding OUTPUT DataPoint (matching data_point_id) produced by another potential task within that same plan's graph.




Rationale: Ensures published templates are structurally sound for every plan offered. Validates assignments, types, conditions, and graph completeness specifically for the set of task models chosen in each plan.
Acceptance Criteria:
Validation logic iterates through each plan for checks 4 & 5.
Publish operation fails with descriptive errors if any validation fails for any plan.
Successful validation allows status change to 'PUBLISHED'.


Priority: Must Have
Standard/Reference: Business Logic Constraint, Data Integrity, DAG Validation

Module: Petition Instance & Task Instance Creation
REQ-PETI-001
Requirement Type: Functional, Server-Side Logic (triggered by REQ-PETI-ORDER-001)
Description: Upon successful payment and order finalization (via REQ-PETI-ORDER-001), the system MUST:
Create a PetitionInstance record. It MUST be linked to the client_user_id, template_id, plan_id, and the company_id (derived from the client's app flavor context - REQ-APP-001/002). Initial status set to 'IN_PROGRESS' or 'AWAITING_ROOT_FORM'.
Retrieve the Unified Root Form definition (list of DataPoints IDs) associated with the PetitionTemplates.id (from PetitionTemplateRootFormFields).
Create a TaskInstance record for this Root Form task:
Link to the new PetitionInstance.id.
Associate with a predefined "Root Form Task Model" ID (a generic model for data collection).
Set status to 'OPEN'.
Set assigned_user_id to the client_user_id.
Set instance_count to 1.


For this Root Form TaskInstance, create placeholder rows in TaskInstanceData (as per REQ-PETI-003.4) for each DataPoint defined in its Root Form definition.


Rationale: Creates the core petition record and the very first task (Root Form) for the client to interact with, after payment and order confirmation.
Acceptance Criteria:
PetitionInstance record is created correctly with all specified links and initial status.
Unified Root Form definition is correctly retrieved.
The Root Form TaskInstance is created, marked 'OPEN', assigned to the client, and linked to the petition.
Placeholder TaskInstanceData rows are created for all fields of the root form.


Priority: Must Have
Standard/Reference: Workflow Initiation
REQ-PETI-002
Requirement Type: Functional, API
Description: POST /v1/tasks/{taskId}/submit (for Root Form)... Validates submitted data against the expected DataPoints definition for the Root Form. For each submitted data point:
Finds the corresponding data_point_id.
Creates/updates a record in TaskInstanceData linking it to the Root Form task_instance_id, the data_point_id, setting instance_index=0, and storing the value in the appropriate value_* column.
Marks the Root Form TaskInstance as 'COMPLETED'.
Triggers the Task Instance Generation Process (REQ-PETI-003).


Rationale: Captures root form data into the normalized TaskInstanceData structure and triggers subsequent task creation.
Acceptance Criteria:
Endpoint validates data against DataPoints definitions.
Data saved correctly into TaskInstanceData linked to the root form task instance.
Root form task status updated. Triggers next process.


Priority: Must Have
Standard/Reference: REST Principles, OAS 3.x
REQ-PETI-003
Requirement Type: Functional, Server-Side Logic (triggered by REQ-PETI-002)
Description: The Task Instance Generation Process, triggered by Root Form submission, performs the following for the specific PetitionInstance:
Retrieve the submitted Root Form data (from TaskInstanceData linked to the completed Root Form TaskInstance).
Retrieve the plan-specific potential task graph structure (PlanTaskGraphNodes, PlanTaskGraphEdges) associated with the PetitionInstance's plan_id.
Main Graph Task Instantiation: For each PlanTaskGraphNode defined in the plan's structure:
a. Evaluate its invalidation_condition and multiplicity_condition (defined in PetitionTemplateTabDocuments if source_type is 'TAB_DOCUMENT', or use defaults if 'ADMIN_ADDED_ROOT_TASK') using the submitted Root Form data.
b. If the invalidation_condition evaluates to true, create a TaskInstance record and immediately set its status to 'INVALIDATED' and is_invalidated to true. No further processing for this node.
c. If not invalidated, create one TaskInstance record:
i. Link to the PetitionInstance.id, the PlanTaskGraphNode.task_model_id, and PlanTaskGraphNode.document_type_preset_id.
ii. Set instance_count based on the multiplicity_condition (default 1).
iii. Set is_invalidated to false.
iv. Data Placeholder Creation: For this new TaskInstance:
* Identify all unique DataPoint.ids that are either an INPUT or an OUTPUT for its TaskModel (from TaskModelDataPointLinks).
* Additionally, identify any standard OUTPUT DataPoints for its DocumentTypePreset (from DocumentPresetDataPointLinks) not already covered.
* For each such unique DataPoint.id, and for each instance_index from 0 to (TaskInstance.instance_count - 1), create a placeholder row in TaskInstanceData (linking task_instance_id, data_point_id, instance_index) with null values for all value_* columns.
Benefit-Triggered Task Instantiation:
a. Retrieve all active benefits for the PetitionInstance from PetitionInstanceBenefits.
b. For each benefit where Benefits.is_task_triggering is true, retrieve associated TaskModel.id(s) from BenefitTriggeredTaskModels.
c. For each such TaskModel.id, create a new TaskInstance:
i. Link to PetitionInstance.id, the TaskModel.id, and its DocumentTypePreset.
ii. instance_count typically 1 (unless benefit implies multiplicity). is_invalidated typically false.
iii. Create placeholder rows in TaskInstanceData as per step 3.c.iv.
Initial Status Setting for All Created Tasks (Main Graph & Benefit-Triggered):
a. For each newly created, non-invalidated TaskInstance:
i. If it has no prerequisite DataPoints that are evidence-based (or all its evidence-based inputs are satisfied by the Root Form data already marked as 'COMPLETED'), set its status to 'OPEN'.
ii. Otherwise, if it depends on outputs from other tasks in the PlanTaskGraphEdges (or from other benefit-triggered tasks if such dependencies are defined), set its status to 'LOCKED'.


Rationale: Creates the actual, personalized workflow by instantiating tasks from the plan's graph and from benefits, evaluating conditions, setting multiplicity, pre-defining all expected data slots, and determining initial task readiness.
Acceptance Criteria:
Process correctly retrieves potential graph structure and root form data.
Correctly evaluates invalidation_condition and multiplicity_condition.
TaskInstance records are created with correct is_invalidated, instance_count, linked model, and preset.
Placeholder TaskInstanceData rows are created for all expected input and output DataPoints (covering both Task Model specifics and Document Preset standards) for every instance_index.
Benefit-triggered tasks are correctly instantiated with data placeholders.
Initial 'OPEN'/'LOCKED' status for all tasks is correctly set based on dependencies and Root Form completion.


Priority: Must Have
Standard/Reference: Workflow Instantiation, DAG Traversal, Data Integrity



Module: Task Instance Data Model
REQ-TASKINST-001
Requirement Type: Data
Description: The system MUST persist task instance data in a TaskInstances table. Each record represents a specific task for a specific petition instance and MUST include:
id (Primary Key, UUID recommended)
petition_instance_id (UUID, FK to PetitionInstances.id, NOT NULL, Indexed)
task_model_id (UUID, FK to TaskModels.id, NOT NULL)
document_type_preset_id (UUID, FK to DocumentTypePresets.id, NOT NULL) - The primary document this task instance is concerned with.
plan_task_graph_node_id (UUID, Nullable FK to PlanTaskGraphNodes.id) - Links to the node in the pre-defined graph, if applicable (null for benefit-triggered tasks not in the main graph).
status (Enum: 'LOCKED', 'OPEN', 'IN_PROGRESS_CLIENT', 'IN_PROGRESS_TEAM', 'PENDING_REVIEW', 'COMPLETED', 'RETURNED_TO_CLIENT', 'CANCELED', 'INVALIDATED', NOT NULL)
current_step_number (Integer, Nullable, FK to TaskModelSteps.step_number relative to task_model_id) - Current active step.
assigned_user_id (UUID, Nullable FK to Users.id)
assigned_team_id (UUID, Nullable FK to Teams.team_id)
instance_count (Integer, default: 1, NOT NULL) - How many instances of the document/data this task represents.
completed_instance_count (Integer, default: 0, NOT NULL) - Number of instances for which input/processing is complete (for multi-instance tasks).
is_invalidated (Boolean, default: false, NOT NULL)
due_date (TIMESTAMP WITH TIME ZONE, Nullable) - Calculated based on task model step deadlines or overall petition timeline.
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Rationale: Defines the runtime entity for tasks, tracking their state, assignments, multiplicity, validity, and links to workflow definitions. Actual data values are stored separately in TaskInstanceData.
Acceptance Criteria:
Database schema includes TaskInstances table with specified fields, data types, nullability, and constraints.
Enum values for status are defined.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices
REQ-TASKINST-DATA-001
Requirement Type: Data
Description: The system MUST store the actual data values associated with Task Instances in a dedicated TaskInstanceData table. Each row represents a specific data point's value for a specific instance within a task. The table MUST include:
id (Primary Key, UUID recommended)
task_instance_id (FK to TaskInstances, NOT NULL, Indexed)
data_point_id (FK to DataPoints, NOT NULL, Indexed)
instance_index (Integer, default: 0) - Indicates which document instance this data belongs to when TaskInstances.instance_count > 1. 0-based index.
value_string (VARCHAR, nullable)
value_text (TEXT, nullable)
value_integer (BIGINT, nullable)
value_decimal (DECIMAL, nullable)
value_boolean (BOOLEAN, nullable)
value_date (DATE, nullable)
value_datetime (TIMESTAMP WITH TIME ZONE, nullable)
value_file_reference (TEXT, nullable) - Stores path/URL/ID for single file uploads.
value_file_array_reference (JSON, nullable) - Stores array of paths/URLs/IDs for multiple file uploads associated with one DataPoint instance.
value_json (JSONB, nullable) - For complex object structures.
last_updated_by_user_id (FK to Users, nullable)
last_updated_at (TIMESTAMP)


Rationale: Provides a normalized, queryable structure for storing all input and output data associated with task instances. Uses typed columns for common data types and JSON/TEXT for others. Supports multi-instance tasks via instance_index. Replaces input_data/output_data JSON fields in TaskInstances.
Acceptance Criteria:
Database schema includes TaskInstanceData table with specified fields, FKs, and indexes.
A unique constraint SHOULD exist on (task_instance_id, data_point_id, instance_index) to prevent duplicate entries.
Appropriate value_* column is used based on the associated DataPoints.data_type.


Priority: Must Have
Standard/Reference: Data Modeling Best Practices, Database Normalization

Module: Potential Task Graph Structure (Detailed Definitions)
REQ-GRAPH-STORE-001
Requirement Type: Data
Description: The system MUST store the definition of potential task nodes for each plan in a PlanTaskGraphNodes table. Each row represents a potential task that could be instantiated for a petition using this plan. It MUST include:
id (Primary Key, UUID recommended)
plan_id (FK to PetitionTemplatePlans, NOT NULL, Indexed)
task_model_id (FK to TaskModels, NOT NULL) - The Task Model to be used.
document_type_preset_id (FK to DocumentTypePresets, NOT NULL) - The primary document this node aims to produce/collect.
source_type (Enum: 'TAB_DOCUMENT', 'ADMIN_ADDED_ROOT_TASK', 'INITIAL_FORM_TASK', default: 'TAB_DOCUMENT') - Indicates how this node was defined.
source_tab_document_id (Nullable FK to PetitionTemplateTabDocuments) - If source_type is 'TAB_DOCUMENT'.
node_identifier (TEXT, Unique within a plan_id) - A stable, human-readable or system-generated unique ID for this node within the plan's graph (e.g., "PassportUpload", "CoverLetterDraft_PlanA"). Useful for referencing in dependencies.


Rationale: Clearly defines each potential task (node) within a specific plan's workflow, its associated model and document, and how it originated (from a tab or added by an admin to fulfill a dependency). Replaces PlanPotentialTaskNodes with a more descriptive name and clear fields.
Acceptance Criteria:
Database schema includes PlanTaskGraphNodes table with specified fields, FKs, and constraints.
Enum values for source_type are defined.
A unique constraint exists on (plan_id, node_identifier).


Priority: Must Have
Standard/Reference: Data Modeling, Graph Theory
REQ-GRAPH-STORE-002
Requirement Type: Data
Description: The system MUST store the dependencies (edges) between potential task nodes for each plan in a PlanTaskGraphEdges table. Each row represents a directed dependency where one task must be completed (or a specific output DataPoint from it must be available) before another task can begin or proceed. It MUST include:
id (Primary Key, UUID recommended)
plan_id (FK to PetitionTemplatePlans, NOT NULL, Indexed) - Though derivable via nodes, explicit linking simplifies queries for a plan's entire edge set.
prerequisite_node_id (FK to PlanTaskGraphNodes, NOT NULL) - The node that must be completed first.
dependent_node_id (FK to PlanTaskGraphNodes, NOT NULL) - The node that depends on the prerequisite.
triggering_data_point_id (FK to DataPoints, NOT NULL) - The specific output DataPoint from the prerequisite_node_id that satisfies an evidence-based input requirement of the dependent_node_id. This DataPoint must be declared as an OUTPUT of the prerequisite node's TaskModel and an evidence-based INPUT of the dependent node's TaskModel.


Rationale: Explicitly defines the directed edges of the task graph for each plan, clearly stating which output from a prerequisite task triggers a dependency for a subsequent task. This allows for precise tracking of data flow and readiness of tasks. Replaces PlanPotentialTaskDependencies.
Acceptance Criteria:
Database schema includes PlanTaskGraphEdges table with specified fields, FKs, and constraints.
A unique constraint SHOULD exist on (plan_id, prerequisite_node_id, dependent_node_id, triggering_data_point_id) to prevent duplicate dependency definitions for the same data flow.
Validation ensures that triggering_data_point_id is indeed an output of the prerequisite's Task Model and an input of the dependent's Task Model.


Priority: Must Have
Standard/Reference: Data Modeling, Directed Acyclic Graph (DAG) Representation
REQ-GRAPH-STORE-003
Requirement Type: Data
Description: The system MUST associate the unified Root Form definition with each Petition Template. This is stored in a PetitionTemplateRootFormFields table, linking the template_id to the data_point_id of each field required on the root form, along with its display order.
id (Primary Key)
template_id (FK to PetitionTemplates, NOT NULL)
data_point_id (FK to DataPoints, NOT NULL)
order (Integer)


Rationale: Stores the ordered list of DataPoints that constitute the initial data collection form for the template, common across all plans.
Acceptance Criteria:
Database schema includes PetitionTemplateRootFormFields table.
A unique constraint exists on (template_id, data_point_id).


Priority: Must Have
Standard/Reference: Data Modeling
REQ-GRAPH-CALC-001
Requirement Type: Server-Side Logic, Functional
Description: As part of the "Save & Validate" or "Publish" process for a Petition Template (within REQ-PTMPL-VALIDATE-001), the system MUST perform the following analysis for each Plan associated with the template to define its potential task graph:
Node Identification:
Identify all PetitionTemplateTabDocuments for the template. For each, determine the TaskModel assigned under the current Plan (via PlanDocumentTaskModels). Create a PlanTaskGraphNode record for each of these, with source_type = 'TAB_DOCUMENT'.
(Iterative Step from REQ-PTMPL-VALIDATE-001.6.d) If the admin defines "Admin-Added Root Tasks" to satisfy missing evidence, create PlanTaskGraphNode records for these as well, with source_type = 'ADMIN_ADDED_ROOT_TASK'. Assign unique node_identifier to all nodes.


Edge Identification (Dependency Mapping):
For every PlanTaskGraphNode in the current plan:
Retrieve its required INPUT DataPoints that are flagged as is_evidence_based=true (from TaskModelDataPointLinks associated with the node's TaskModel).
For each such evidence-based input DataPoint:
Search all other PlanTaskGraphNodes within the same plan for a node whose TaskModel produces a matching data_point_id as an OUTPUT (from TaskModelDataPointLinks).
If a producing node is found, create a PlanTaskGraphEdge record linking the producing node (as prerequisite_node_id) to the consuming node (as dependent_node_id), specifying the triggering_data_point_id.
Also consider the DataPoints collected by the Unified Root Form (PetitionTemplateRootFormFields) as potential outputs from an implicit "Initial Form Completion" event. If an evidence-based input matches a Root Form DataPoint, an edge can be conceptualized from this event (though not necessarily stored as a node-to-node edge if the "Initial Form Node" isn't in PlanTaskGraphNodes).






Storage: Persist the calculated PlanTaskGraphNodes and PlanTaskGraphEdges for the plan. Delete and recreate if re-validating.


Rationale: Formalizes the algorithm for calculating and storing the potential task graph structure for each plan during template design time. This structure is then used for validation and later for instantiating actual tasks. This replaces the less formal "Algorithm Note" and parts of the old REQ-PTMPL-GRAPH-DEF-001.
Acceptance Criteria:
The graph calculation process is triggered during template save/validation for each plan.
PlanTaskGraphNodes are correctly created for all tab-documents and admin-added root tasks.
PlanTaskGraphEdges are correctly created by matching evidence-based INPUT DataPoints to OUTPUT DataPoints from other nodes or the root form, using data_point_id for matching.
The generated graph structures are correctly persisted in the database for each plan.


Priority: Must Have
Standard/Reference: Graph Theory, Algorithm Design, Data Integrity
REQ-GRAPH-ROOTFORM-CALC-001
Requirement Type: Server-Side Logic, Functional
Description: As part of the "Save & Validate" or "Publish" process for a Petition Template, the system MUST determine and store a single, unified Root Form definition for the template:
Collect all DataPoint.ids referenced by system_name in any invalidation_condition or multiplicity_condition across all PetitionTemplateTabDocuments.
Collect all INPUT DataPoint.ids from TaskModelDataPointLinks where is_separate_request is false AND is_evidence_based is false, for all Task Models assigned in any Plan of the template.
Consolidate a unique set of these DataPoint.ids.
For each unique DataPoint.id, create/update a record in PetitionTemplateRootFormFields, storing template_id, data_point_id, and a defined display_order for the root form.


Rationale: Formalizes the process of identifying all DataPoints needed for the unified initial data collection form, ensuring all conditional logic and non-derived task inputs are covered. Replaces parts of the old REQ-PTMPL-GRAPH-DEF-001 and REQ-PTMPL-ROOTFORM-DEF-001.
Acceptance Criteria:
Root form calculation process is triggered during template save/validation.
All necessary DataPoints are correctly identified from conditions and non-separate, non-evidence-based task inputs across all plans.
PetitionTemplateRootFormFields table is accurately populated with the unique list of DataPoints and their order.


Priority: Must Have
Standard/Reference: Data Modeling, Algorithm Design
Module: Task Instance Lifecycle, Statuses & Steps
REQ-TASKINST-LIFE-001
Requirement Type: Functional
Description: Task Instances MUST progress through a defined set of statuses. The primary statuses are:
LOCKED: The task cannot be started yet as its prerequisite tasks/steps are not complete.
OPEN: All prerequisites are met, and the task is ready for input/action by the assigned party (Client or Team member).
IN_PROGRESS_CLIENT: The Client has started providing input or working on the task.
IN_PROGRESS_TEAM: An internal (NN/Vendor) team member has started working on the task (e.g., review, drafting).
PENDING_REVIEW: The Client has submitted their input, and it's awaiting review by the assigned team member. (Replaces 'IN_REVIEW' for clarity of whose court the ball is in).
COMPLETED: All steps for the task are finished, and the final output (if any) is stored. This makes its output DataPoints available for dependent tasks.
RETURNED_TO_CLIENT: A team member has reviewed client input and found issues, returning the task to the client with feedback for revisions. Status effectively reverts to OPEN or IN_PROGRESS_CLIENT for the client.
CANCELED: An optional task that was not needed or explicitly canceled by the client or an authorized employee.
INVALIDATED: The task was determined to be not applicable based on root form data (evaluation of invalidation_condition). These tasks are effectively skipped.


Rationale: Defines a clear lifecycle for tasks, indicating their state and who is responsible for the next action.
Acceptance Criteria:
The defined statuses are implemented and used consistently.
Transitions between statuses are governed by specific actions/events.


Priority: Must Have
Standard/Reference: Workflow Management
REQ-TASKINST-LIFE-002
Requirement Type: Functional, Server-Side Logic
Description: The system MUST manage task step progression for each TaskInstance. When a step is completed:
The TaskInstance.current_step_number is updated to the success_target_step_number defined in the TaskModelSteps.
If the step involved input validation and failed, current_step_number is updated to the failure_target_step_number.
If the new current_step_number corresponds to a step assigned to a different role (e.g., Client completes input, next step is Team review), the task status updates accordingly (e.g., to PENDING_REVIEW).
If the final step of the Task Model is completed successfully, the TaskInstance.status is set to COMPLETED. The system then MUST check for any dependent tasks (via PlanTaskGraphEdges for the petition's plan) and transition their status from LOCKED to OPEN if all their prerequisites are now COMPLETED.


Rationale: Automates the flow through a task's defined steps and triggers the unlocking of subsequent tasks in the overall petition graph.
Acceptance Criteria:
Step completion correctly updates current_step_number.
Task status changes appropriately based on new step's assignee.
Completion of the final step sets task status to COMPLETED.
Dependent tasks are correctly transitioned to OPEN when all their prerequisites are met.


Priority: Must Have
Standard/Reference: Workflow Automation, DAG Traversal
REQ-TASKINST-LIFE-003
Requirement Type: Functional, API
Description: API endpoints MUST exist for users to interact with tasks assigned to them, facilitating step progression and status changes:
POST /v1/tasks/{taskInstanceId}/start: Allows a user (Client or Team member) to signal they are beginning work on an 'OPEN' task, changing its status to IN_PROGRESS_CLIENT or IN_PROGRESS_TEAM.
POST /v1/tasks/{taskInstanceId}/steps/{stepNumber}/submit-input: Client/Employee submits data for the current input step. (Data saved to TaskInstanceData as per REQ-TASKINST-INTERACT-001). Triggers progression to next step (validation or completion).
POST /v1/tasks/{taskInstanceId}/steps/{stepNumber}/approve-review: Team member approves a review step. Triggers progression.
POST /v1/tasks/{taskInstanceId}/steps/{stepNumber}/reject-review: Team member rejects a review step. Triggers progression to failure step (often back to client input) and requires feedback (REQ-TASKINST-INTERACT-003).
POST /v1/tasks/{taskInstanceId}/cancel: Client/Employee cancels an optional, open task. Status changes to CANCELED.


Rationale: Provides the necessary API calls for users to perform actions on tasks, driving the workflow.
Acceptance Criteria:
Specified endpoints exist, perform described actions, and update task/step status.
Authorization restricts endpoint access to the currently assigned user/role for the task/step.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: REST Principles, Workflow APIs, OAS 3.x

Module: Task Instance Interaction & Data Handling
REQ-TASKINST-INTERACT-001
Requirement Type: Functional, API, Data, UI
Description: When a user submits input for a task step (POST /v1/tasks/{taskInstanceId}/steps/{stepNumber}/submit-input), the API MUST:
Identify the DataPoints expected as input for the current TaskModelStep (derived from TaskModelDataPointLinks for the TaskInstance.task_model_id).
For each expected input DataPoint, validate the submitted data against its data_type and any validation_rules defined in the DataPoints table (e.g., regex, min/max length/value).
The submitted payload MUST support providing distinct data for each instance if TaskInstance.instance_count > 1.
For each submitted data point and for each instance_index (from 0 to TaskInstance.instance_count - 1, if applicable): Create or update TaskInstanceData.
Update TaskInstance.completed_instance_count.
Client UI MUST allow providing distinct inputs for each instance and SHOULD provide client-side validation hints based on DataPoints.validation_rules and data_type.


Rationale: Ensures data is validated against centrally defined rules in DataPoints.
Acceptance Criteria:
API validates submitted data against DataPoints.data_type and DataPoints.validation_rules.
Data saved to TaskInstanceData. UI supports multi-instance input.


Priority: Must Have
Standard/Reference: Data Validation, OWASP A03:2021
REQ-TASKINST-INTERACT-002
Requirement Type: Functional, API, Data
Description: When a task step involves generating an output (e.g., a team member drafts a document, an AI process generates text), the API handling that step's completion MUST:
Identify the DataPoints expected as output for that step/task (from TaskModelDataPointLinks).
For each output DataPoint and for each instance_index (if applicable):
Create or update the corresponding record in TaskInstanceData, storing the output value/reference.




Rationale: Ensures outputs generated by team members or AI are also stored correctly in TaskInstanceData.
Acceptance Criteria:
API correctly identifies expected output DataPoints for the step.
Output data/references are saved to TaskInstanceData for the correct task_instance_id, data_point_id, and instance_index.


Priority: Must Have
Standard/Reference: -
REQ-TASKINST-INTERACT-003
Requirement Type: Data, Functional
Description: The system MUST support comments on Task Instances. A TaskComments table MUST be created, including:
id (Primary Key)
task_instance_id (FK to TaskInstances, NOT NULL)
user_id (FK to Users - commenter, NOT NULL)
comment_text (TEXT, NOT NULL)
created_at (Timestamp)
is_feedback_for_rejection (Boolean, default: false) - If true, this comment is the official reason for a review rejection.


Rationale: Facilitates communication between clients and team members regarding specific tasks. Allows formal feedback on rejections.
Acceptance Criteria:
TaskComments table schema exists.
API endpoints (POST /v1/tasks/{taskInstanceId}/comments, GET /v1/tasks/{taskInstanceId}/comments) exist for adding and retrieving comments, documented in OAS.
When a review is rejected (POST /v1/tasks/{taskInstanceId}/steps/{stepNumber}/reject-review), the API MUST require a comment to be submitted and flag it as is_feedback_for_rejection.


Priority: Must Have
Standard/Reference: OAS 3.x
REQ-TASKINST-INTERACT-004
Requirement Type: Functional
Description: Clients and assigned team members MUST be able to view the detailed description for the current task (from TaskModels.description_content_id) and the current step (from TaskModelSteps.description_content_id). The client application MUST render the rich content (HTML, Markdown, etc.) from the referenced ContentBlocks.
Rationale: Provides necessary guidance using centrally managed rich content.
Acceptance Criteria:
Client UIs retrieve and render content from the appropriate ContentBlocks for task and step descriptions.


Priority: Must Have
Standard/Reference: User Experience
REQ-TASKINST-INTERACT-005
Requirement Type: Functional, Data Persistence
Description: Client-side input progress for tasks (partially filled forms, documents selected for upload but not yet submitted) SHOULD be saved locally on the client device to prevent data loss if the app is closed. Upon returning to the task, this local state SHOULD be restored. Final submission still goes through the API.
Rationale: Improves user experience by preserving work in progress.
Acceptance Criteria:
Flutter client implements local state persistence for active task inputs.
State is restored when the user re-opens the task.


Priority: Should Have
Standard/Reference: Mobile App Best Practices
REQ-TASKINST-INTERACT-006
Requirement Type: Functional, API, UI
Description: The Task Details screen (as seen in mockup) MUST feature a "Request Assistance" option. Tapping this option will:
Present the user with relevant assistance options for the current TaskInstance. These options may include:
Upgrading the task to a different TaskModel (if available, linking to the Task Upgrade Selection Screen REQ-SCR-TUS-001). The GET /v1/tasks/{taskInstanceId}/available-upgrades API would be called.
Purchasing a relevant Benefit as an add-on (e.g., "1:1 Attorney Consultation") if not already acquired (linking to a focused add-on purchase screen, see REQ-ADDON-POST-001). The GET /v1/petitions/{petitionInstanceId}/available-addons API, possibly filtered for context-relevant benefits, would be called.
Initiating a support message/ticket related to this task (linking to a messaging interface or creating a new support ticket entry).


The specific options presented MUST be contextually determined by the backend based on the task, its current model, available upgrades, and relevant purchasable benefits. An API endpoint (e.g., GET /v1/tasks/{taskInstanceId}/assistance-options) will provide these categorized options to the client.


Rationale: Provides users with clear pathways to get help or enhance service for a specific task, improving user support and potentially driving upsells.
Acceptance Criteria:
"Request Assistance" option is present on the Task Details UI.
API endpoint GET /v1/tasks/{taskInstanceId}/assistance-options exists, returning structured data on available upgrades, relevant add-ons, and/or support contact options.
Client UI correctly displays these options and navigates the user to the appropriate flow (Task Upgrade screen, Add-on purchase, or Support/Messaging).
Endpoint documented in OAS.


Priority: Should Have
Standard/Reference: User Support, In-App Upselling

Module: Dashboards & Task Views
REQ-DASH-001 (Client Dashboard)
Requirement Type: Functional, API
Description: Logged-in Clients (CLIENT role) MUST see a dashboard displaying:
A list of their active PetitionInstances (status 'IN_PROGRESS').
For each petition, a summary of currently 'OPEN' or IN_PROGRESS_CLIENT tasks assigned to them, or tasks RETURNED_TO_CLIENT.
A clear call to action to start a new petition if no active ones exist.


Rationale: Provides clients with an overview of their ongoing applications and pending actions.
Acceptance Criteria:
API endpoint (GET /v1/client/dashboard or similar) provides the necessary data.
Client UI renders the dashboard as described.
Data is filtered to the current client's petitions and tasks.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: -
REQ-DASH-002 (Employee/Manager Dashboard)
Requirement Type: Functional, API
Description: Logged-in Employees/Managers (NN or Vendor) MUST see a dashboard displaying tasks relevant to them:
NN_EMPLOYEE/VENDOR_EMPLOYEE: Tasks directly assigned to them (TaskInstances.assigned_user_id = currentUser.id) that are 'OPEN' or 'IN_PROGRESS_TEAM' or PENDING_REVIEW.
NN_MANAGER/VENDOR_MANAGER:
Their own assigned tasks (as above).
Tasks assigned to members of teams they own (TaskInstances.assigned_team_id in their owned teams AND TaskInstance.status is 'OPEN', 'IN_PROGRESS_TEAM', or PENDING_REVIEW).
Ability to filter tasks by team member, due date, status.




Rationale: Provides internal users with a view of their workload and, for managers, their team's workload.
Acceptance Criteria:
API endpoint (GET /v1/team/dashboard or similar) provides task data based on user role, assignments, and team ownership.
Dashboard UI renders tasks according to role-specific views.
Filtering capabilities are implemented.
Authorization ensures users only see tasks they are permitted to see based on REQ-AUTHZ-002.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: -
REQ-DASH-003 (Admin Dashboard)
Requirement Type: Functional, API
Description: Logged-in Admins (NN or Vendor) MUST see a dashboard with broader task visibility:
VENDOR_ADMIN: All tasks within their company, filterable by status, employee, manager, team, due date.
NN_ADMIN: All tasks across all companies, filterable by company, status, employee, manager, team, due date.


Rationale: Provides admins with oversight capabilities.
Acceptance Criteria:
API endpoint (GET /v1/admin/dashboard/tasks or similar) provides comprehensive task data based on admin role and company scope.
Dashboard UI allows extensive filtering.
Authorization enforced.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: -
REQ-DASH-004 (Task Assignment/Reassignment)
Requirement Type: Functional, API
Description:
Tasks are initially auto-assigned to a team (or client) based on TaskModelStep.assigned_role. For team-assigned steps, a specific user assignment within the team might be round-robin, least-loaded, or unassigned initially.
Managers (NN_MANAGER, VENDOR_MANAGER) MUST be able to reassign tasks (change TaskInstances.assigned_user_id) that are currently assigned to their team or a member of their team, to another member of their team (respecting requires_lawyer_assignment on the Task Model).
Admins (NN_ADMIN, VENDOR_ADMIN) MUST be able to reassign tasks within their scope similarly.


Rationale: Allows for load balancing and management of task distribution within teams.
Acceptance Criteria:
API endpoint (PATCH /v1/tasks/{taskInstanceId}/assign) allows updating assigned_user_id.
Authorization restricts reassignment based on manager/admin role and team/company scope.
Validation ensures new assignee is eligible (e.g., lawyer status if required).
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: RBAC, ABAC
REQ-DASH-005
Requirement Type: Functional, UI
Description: When a client views the list of tasks for a specific petition (as in "Task List for a Petition Screen" mockup), in addition to tasks grouped by "Your Turn," "In Review," and "Completed," the UI SHOULD also display tasks that are currently 'LOCKED'.
Locked tasks should be visually distinct (e.g., greyed out, lock icon) and clearly indicate they are not yet actionable.
Displaying locked tasks provides the client with a full overview of the petition's scope and upcoming work.


Rationale: Improves transparency for the client by showing the entire remaining workflow, not just immediately actionable items.
Acceptance Criteria:
The API providing tasks for the petition task list includes 'LOCKED' tasks.
The client UI displays a section for "Upcoming" or "Locked" tasks, visually differentiated from actionable tasks.
Locked tasks are not interactive for input submission but might allow viewing their description.


Priority: Should Have
Standard/Reference: User Experience, Transparency

Module: Add-ons & Task Upgrades
REQ-ADDON-001
Requirement Type: Functional, Data
Description:
When a client is selecting add-ons for a petition (associated with a specific template_id and chosen plan_id):
Available add-ons are determined by querying PetitionTemplateAvailableAddons for the template_id.
From this list, filter out any Benefit that is already included in the client's chosen plan (by checking PlanIncludedBenefits for the plan_id).
A PetitionInstanceBenefits table tracks all benefits active for a PetitionInstance. Each record includes id, petition_instance_id (FK), benefit_id (FK), source (Enum: 'PLAN_INCLUDED', 'ADDON_PURCHASED'), purchase_date (if ADDON_PURCHASED), cost_paid (if ADDON_PURCHASED).
Benefit Task Instantiation: If an acquired Benefit (either from PLAN_INCLUDED or ADDON_PURCHASED) has is_task_triggering = true and a triggered_task_model_id:
A new TaskInstance MUST be created for the PetitionInstance using this triggered_task_model_id.
These benefit-triggered tasks are distinct from the main document-driven task graph.
Rationale: Clarifies how the list of purchasable add-ons is derived and how all acquired benefits (plan-included or purchased) are tracked and trigger tasks.
Acceptance Criteria:
Logic correctly determines available add-ons for purchase by comparing PetitionTemplateAvailableAddons with PlanIncludedBenefits for the selected plan.
PetitionInstanceBenefits table accurately tracks all acquired benefits and their source.
Acquiring any task-triggering benefit (regardless of source) correctly creates its associated TaskInstance.


Priority: Must Have
Standard/Reference: -
REQ-ADDON-002
Requirement Type: Functional, API
Description:
GET /v1/petition-templates/{templateId}/plans/{planId}/purchasable-addons: New endpoint (or modified existing one) to list Benefits that can be purchased as add-ons specifically for a given template and chosen plan. This endpoint internally performs the logic from REQ-ADDON-001.1.
Client petition creation flow allows selection of these purchasable add-ons after plan selection, before final payment.
The POST /v1/petitions/initiate-checkout (or similar) API takes template_id, plan_id, and an array of selected addon_benefit_ids (which are the benefit_ids of the chosen purchasable add-ons).
This endpoint calculates total cost (plan_cost + sum of selected add-on_benefit_costs from Benefits.cost).
Upon successful payment:
PetitionInstance is created.
Benefits from the plan (via PlanIncludedBenefits) are recorded in PetitionInstanceBenefits with source 'PLAN_INCLUDED'.
Purchased add-on benefits are recorded in PetitionInstanceBenefits with source 'ADDON_PURCHASED' and cost paid.
All relevant benefit-triggered tasks are created.
Root Form task is generated.




Rationale: Integrates add-on selection into the initial petition setup flow, allowing for a single checkout transaction.
Acceptance Criteria:
New API endpoint correctly lists purchasable add-ons for a specific plan context.
Client flow allows selection.
Checkout API calculates total cost correctly.
Successful payment correctly populates PetitionInstanceBenefits distinguishing plan-included vs. purchased add-ons.
All relevant tasks (benefit-triggered and root form) are created.
Endpoint and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: E-commerce Checkout Flow Best Practices
REQ-ADDON-003
Requirement Type: Functional, Data
Description: Some Benefits (add-ons or plan-included) MAY trigger the creation of new TaskInstances or modify existing ones. The definition of how a Benefit impacts tasks MUST be configurable (e.g., a BenefitTaskTriggers table linking benefit_id to task_model_id to be added, or specifying a target document_type_preset_id for which an existing task's model should be upgraded).
Rationale: Connects the acquisition of benefits to concrete changes in the petition's workflow.
Acceptance Criteria:
Mechanism exists to define task-related outcomes of acquiring a benefit.
Acquiring such a benefit triggers the appropriate task creation or modification.


Priority: Must Have
Standard/Reference: -
REQ-ADDON-POST-001
Requirement Type: Functional, API, Data
Description: Clients MUST be able to purchase additional Benefits (add-ons) for an existing, active PetitionInstance.
Available Add-ons API: An endpoint GET /v1/petitions/{petitionInstanceId}/available-purchase-addons MUST list Benefits that can be purchased. This list is derived by:
Taking all Benefits linked to the petition's PetitionTemplate.id via PetitionTemplateAvailableAddons.
Filtering out any Benefit.id that already exists for this petition_instance_id in the PetitionInstanceBenefits table.
The response should include benefit name, description, and Benefits.cost.


Purchase API: An endpoint POST /v1/petitions/{petitionInstanceId}/purchase-addons allows a client to select one or more available add-ons. Request includes an array of benefit_ids.
Calculates total cost of selected add-ons.
Integrates with a payment gateway if total cost > 0.
Upon successful payment (or if free):
For each purchased benefit_id, a new record is added to PetitionInstanceBenefits with source = 'ADDON_PURCHASED_POST_CREATION', cost_paid, and purchase_date.
If any purchased benefit has Benefits.is_task_triggering = true, the corresponding TaskInstance(s) (linked via BenefitTriggeredTaskModels) are created for the PetitionInstance (as per logic in REQ-PETI-003.4 & .5 for data placeholders and status).






Rationale: Provides clients the flexibility to add services to their active petition after initial setup. This complements the initial add-on selection.
Acceptance Criteria:
GET /v1/petitions/{petitionInstanceId}/available-purchase-addons correctly lists purchasable add-ons.
POST /v1/petitions/{petitionInstanceId}/purchase-addons endpoint processes selection, handles payment, updates PetitionInstanceBenefits, and triggers new task instantiation for task-triggering benefits.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: E-commerce, REST Principles, OAS 3.x
REQ-ADDON-BENEFIT-EFFECT-001 (Consolidating REQ-ADDON-003 from file)
Requirement Type: Functional, Server-Side Logic
Description: Whenever a Benefit is associated with a PetitionInstance (either through plan inclusion at petition creation, initial add-on purchase via REQ-PETI-ORDER-001, or post-creation add-on purchase via REQ-ADDON-POST-001), if that Benefit.is_task_triggering is true, the system MUST instantiate the corresponding TaskModel(s) as defined in BenefitTriggeredTaskModels (REQ-PTMPL-BEN-TASKLINK-001).
These new TaskInstance(s) are linked to the PetitionInstance.
Placeholder TaskInstanceData rows are created.
Initial status ('OPEN' or 'LOCKED') is set based on their TaskModel's input requirements (if they depend on root form data or other prerequisites).


Rationale: Ensures that acquiring a benefit, irrespective of timing, consistently triggers its associated tasks in the workflow.
Acceptance Criteria:
Acquisition of any task-triggering benefit correctly and consistently creates its associated TaskInstance(s) with appropriate data placeholders and initial status.


Priority: Must Have
Standard/Reference: Workflow Automation
REQ-TASKUPG-001
Requirement Type: Functional, Data
Description: The system MUST allow clients or authorized team members to "upgrade" an existing TaskInstance to use a different, typically more comprehensive or assisted, TaskModel. An upgrade is only possible if:
The target TaskModel is for the same DocumentTypePreset as the current task.
The target TaskModel has a cost greater than the current task's TaskModel.cost.
The current task is in an appropriate status (e.g., 'OPEN', 'IN_PROGRESS_CLIENT', 'RETURNED_TO_CLIENT').


Rationale: Allows users to opt for more assistance on specific tasks even after starting the petition.
Acceptance Criteria:
Logic correctly identifies valid upgrade paths for a task instance.


Priority: Must Have
Standard/Reference: -
REQ-TASKUPG-002
Requirement Type: Functional, API
Description: API endpoints MUST exist for task upgrades:
GET /v1/tasks/{taskInstanceId}/available-upgrades: Lists available TaskModels (name, description, additional cost) that the specified task instance can be upgraded to.
POST /v1/tasks/{taskInstanceId}/upgrade: Allows a client to select and initiate purchase of a task upgrade. Requires target task_model_id. Integrates with a payment gateway for the cost difference. Upon successful payment:
The TaskInstance.task_model_id is updated.
The TaskInstance.current_step_number MAY be reset to the first step of the new model, or intelligently mapped if possible. Existing TaskInstanceData relevant to the new model should be preserved. New placeholder TaskInstanceData rows for additional inputs/outputs of the new model MUST be created.
The task status may need adjustment (e.g., back to 'OPEN').




Rationale: Provides interface for upgrading tasks and handles associated payment and state changes.
Acceptance Criteria:
Endpoints exist and function as described.
Payment integration handles cost difference.
TaskInstance is updated correctly (model, step, status).
TaskInstanceData is appropriately adjusted/extended for the new model.
Endpoints and schemas are documented in OAS.


Priority: Must Have
Standard/Reference: Payment Gateway Integration, REST Principles, OAS 3.x

Module: Content Management (NEW - for Reusable Rich Content)
REQ-CONTENT-001
Requirement Type: Data, Functional
Description: The system MUST provide a mechanism for managing reusable blocks of rich content (e.g., HTML, Markdown, or structured JSON for templating engines) to be used for PDF generation components (cover pages, indexes, tab dividers) and filing instructions. This will be stored in a ContentBlocks table:
id (Primary Key, UUID recommended)
name (TEXT, Unique, human-readable identifier, e.g., "USCIS_Cover_Page_Template_v1", "H1B_Self_Filing_Instructions_v2")
content_type (Enum: 'HTML', 'MARKDOWN', 'JSON_TEMPLATE_DATA', 'PLAIN_TEXT', NOT NULL)
content (TEXT, storing the actual content, NOT NULL)
version (Integer, default: 1, NOT NULL)
description (TEXT, Nullable, for admin reference)
created_by_user_id (UUID, FK to Users.id)
updated_by_user_id (UUID, FK to Users.id)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Rationale: Centralizes management of templated or rich text content used in various parts of the system, particularly for document generation and dynamic instructions.
Acceptance Criteria:
Database schema includes ContentBlocks table with specified fields.
NN Admins (or designated content managers) can CRUD ContentBlocks via a dedicated internal API/interface.


Priority: Must Have (to support REQ-PFILE-001 & REQ-PFILE-005 effectively)
Standard/Reference: Content Management Systems Principles, Data Modeling

Module: Petition Filing & Completion
REQ-PFILE-001
Requirement Type: Data
Description: The PetitionTemplateTypes table (or a dedicated PetitionTypeCompilationConfig table linked to it) MUST store references to ContentBlocks that define templates for PDF components:
cover_page_content_id (UUID, Nullable FK to ContentBlocks.id)
index_page_content_id (UUID, Nullable FK to ContentBlocks.id)
tab_divider_content_id (UUID, Nullable FK to ContentBlocks.id)


Rationale: Allows customization of the compiled PDF's appearance per petition type using centrally managed, versionable content blocks.
Acceptance Criteria:
Relevant table (PetitionTemplateTypes or new config table) includes FKs to ContentBlocks.id.
NN Admins can associate specific ContentBlocks with these PDF components during PetitionTemplateType setup.


Priority: Should Have (for PDF customization)
Standard/Reference: Data Modeling
REQ-PFILE-002
Requirement Type: Functional, Server-Side Logic
Description: Once all mandatory, non-invalidated TaskInstances for a PetitionInstance are 'COMPLETED', the system MUST enable a "Compile Petition" process. This server-side process will:
Retrieve all output DataPoints (especially FILE_REFERENCE types) from TaskInstanceData for all completed tasks, respecting instance_count and instance_index.
Organize these documents according to the PetitionTemplateTabs order and the document order within tabs.
Generate a cover page using cover_page_template_ref and petition data (client name, petition type).
Generate an index page listing all tabs and their documents.
Generate tab divider pages.
Assemble all generated pages and collected documents into a single, consolidated PDF file.
Store this final PDF securely (see File Management REQ-FMAN-002) and link it to the PetitionInstance.


Rationale: Automates the creation of the final petition document package.
Acceptance Criteria:
Process is triggered when all tasks are complete.
Correctly retrieves and orders all documents.
Generates cover, index, and tab dividers as per templates.
Produces a single, well-formed PDF.
PDF is securely stored and linked.


Priority: Must Have
Standard/Reference: PDF Generation Libraries (e.g., pdf-lib, Puppeteer)
REQ-PFILE-003
Requirement Type: Data
Description: Petition Templates MUST allow NN Admins to define "Filing Steps" if a "Filing Included" type Benefit is available/selected for the PetitionTemplateType. These steps are stored in a PetitionTemplateFilingSteps table:
id (Primary Key)
template_id (FK to PetitionTemplates)
step_number (Order of the step)
step_name (e.g., "Printing & Organizing", "Mailing to USCIS", "Receipt Notice Received")
description (Optional details)
estimated_duration_days (Optional)


Rationale: Defines the trackable stages for petitions where the company handles filing.
Acceptance Criteria:
PetitionTemplateFilingSteps table exists.
NN Admins can define these steps via an API when creating/editing templates.


Priority: Must Have
Standard/Reference: -
REQ-PFILE-004
Requirement Type: Data, Functional
Description: For PetitionInstances where a "Filing Included" Benefit is active, the system MUST track the progress through these filing steps. A PetitionInstanceFilingProgress table will store:
id (Primary Key)
petition_instance_id (FK)
filing_step_template_id (FK to PetitionTemplateFilingSteps)
status (Enum: 'PENDING', 'IN_PROGRESS', 'COMPLETED', 'ON_HOLD')
completed_at (Timestamp, nullable)
notes (TEXT, nullable)


Rationale: Allows tracking and displaying filing status to clients and internal teams.
Acceptance Criteria:
PetitionInstanceFilingProgress table exists.
When such a petition is compiled, entries are created in this table for each defined filing step with status 'PENDING'.
API endpoints (PATCH /v1/petitions/{petitionInstanceId}/filing-steps/{progressId}) allow authorized team members (NN/Vendor employee assigned to filing) to update step status and add notes. Documented in OAS.


Priority: Must Have
Standard/Reference: -
REQ-PFILE-005
Requirement Type: Data
Description: The PetitionTemplates table MUST have a field filing_instructions_content_id (UUID, Nullable FK to ContentBlocks.id). This links to a ContentBlock record containing the rich text/media instructions displayed to clients if they do not have a "Filing Included" benefit.
Rationale: Provides guidance to clients who are self-filing, using centrally managed rich content.
Acceptance Criteria:
PetitionTemplates table has the filing_instructions_content_id field.
NN Admins can select/assign a ContentBlock for filing instructions when creating/editing a Petition Template.


Priority: Must Have
Standard/Reference: Data Modeling
REQ-PFILE-006
Requirement Type: Functional, API
Description: Once a petition's tasks are all 'COMPLETED':
The PetitionInstance status is updated to 'COMPILED' (or similar).
If "Filing Included" is active, the client view shows the current PetitionInstanceFilingProgress timeline.
If "Filing Included" is NOT active, the client view shows the filing_instructions_content.
The client MUST be able to download the compiled PDF (GET /v1/petitions/{petitionInstanceId}/compiled-pdf). Access MUST be authorized.
After all filing steps are 'COMPLETED' (if applicable), the PetitionInstance status can be updated to 'FILED' or 'FINALIZED'.


Rationale: Defines the user experience post-task completion and provides access to the final document.
Acceptance Criteria:
Client UI displays correct information based on filing benefit.
Secure PDF download endpoint exists and is authorized.
Petition status updates reflect compilation and filing completion.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: -
REQ-PFILE-007
Requirement Type: Functional
Description: The system MUST allow authorized users (Client, or NN/Vendor team members with permission) to add updates/notes (e.g., "RFE Received", "Interview Scheduled", "Approved") to a PetitionInstance even after it's considered 'FILED' or 'FINALIZED'. These updates should be timestamped and attributed.
Rationale: Allows for long-term tracking of case outcomes beyond initial filing.
Acceptance Criteria:
A PetitionInstanceUpdates table exists (linking to petition_instance_id, user_id, timestamp, update_text, update_type [Enum]).
API endpoint exists to add and retrieve these updates.


Priority: Should Have
Standard/Reference: -

Module: AI Process Integration
REQ-AI-001
Requirement Type: Data
Description: The system MUST have an AIProcesses table to register available AI processing capabilities. Each record MUST include:
id (Primary Key, UUID recommended)
name (TEXT, Unique, human-readable name, NOT NULL)
description (TEXT, NOT NULL)
process_type (Enum: 'REVIEW_VALIDATION', 'OUTPUT_GENERATION', NOT NULL)
endpoint_url (TEXT, Nullable) - For external AI services.
internal_handler_id (TEXT, Nullable) - For internal AI modules.
managed_by (Enum: 'DEVELOPER', 'AI_ADMIN', NOT NULL)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
(Removed) expected_input_schema_ref, produces_output_schema_ref. These are now defined by linking AIProcesses to DataPoints.


Rationale: Central registry for AI functions, defining their type and invocation method. Specific I/O is managed via a linking table.
Acceptance Criteria:
Database schema includes AIProcesses table with specified fields.
Mechanism exists to manage these AI process definitions.


Priority: Must Have
Standard/Reference: System Integration, API Design
REQ-AI-PROCDP-001 (NEW - Linking AI Processes to DataPoints for I/O)
Requirement Type: Data
Description: A many-to-many relationship MUST exist between AIProcesses and DataPoints to define the specific expected inputs and produced outputs for each AI process. This is stored in an AIProcessDataPointLinks table:
id (Primary Key, UUID)
ai_process_id (FK to AIProcesses.id, NOT NULL)
data_point_id (FK to DataPoints.id, NOT NULL)
direction (Enum: 'INPUT', 'OUTPUT', NOT NULL)
is_required_input (Boolean, Nullable, applicable if direction is 'INPUT')
notes (TEXT, Nullable, e.g., "Primary document file for analysis", "Confidence score for validation")


Rationale: Clearly defines the data contract for each AI process in terms of specific, centrally managed DataPoints, making integration with TaskInstanceData straightforward.
Acceptance Criteria:
Database schema includes AIProcessDataPointLinks table.
Admin/Developer interface allows defining these I/O DataPoints for each AI process.


Priority: Must Have
Standard/Reference: Data Modeling, API Design
REQ-AI-002
Requirement Type: Data (Reference in TaskModelSteps)
Description: The TaskModelSteps table (REQ-TASKM-002) already includes an ai_process_id (Nullable FK to AIProcesses). This field is ONLY populated if the TaskModelSteps.assigned_role is 'AI'.
Rationale: Reiteration and confirmation of how an AI process is linked to a specific step in a task model.
Acceptance Criteria:
ai_process_id in TaskModelSteps correctly references AIProcesses.id.
Business rule: ai_process_id should only be non-null if assigned_role is 'AI'.


Priority: Must Have
Standard/Reference: Data Modeling Consistency
REQ-AI-003
Requirement Type: Functional, Server-Side Logic, Integration
Description: When a TaskInstance's current_step_number points to a TaskModelStep where assigned_role is 'AI' and ai_process_id is populated:
Identify the AIProcess (and its AIProcessDataPointLinks) to be invoked.
Gather required input data: For each linked INPUT DataPoint in AIProcessDataPointLinks, retrieve the corresponding value(s) from TaskInstanceData for the current TaskInstance (respecting instance_index if TaskInstance.instance_count > 1). Prepare data in the format expected by the AI (which might be a structured object containing these data point values).
Invoke the AI process (external via endpoint_url or internal via internal_handler_id).
Handle the AI process's response:
For REVIEW_VALIDATION types: Response expected: approval/denial status, optional message.
Success: Progress to success_target_step_number.
Failure: Progress to failure_target_step_number. Store denial message in TaskComments (REQ-TASKINST-INTERACT-003) associated with the AI user/system.


For OUTPUT_GENERATION types: Response expected: data for specific OUTPUT DataPoints linked via AIProcessDataPointLinks.
For each output DataPoint and for each instance_index (if applicable), parse and store the generated value/reference into the corresponding TaskInstanceData record.
Progress to success_target_step_number.




Implement error handling (AI service unavailability, timeouts, malformed responses), with retry mechanisms or flagging for manual intervention, and robust logging.


Rationale: Defines core logic for AI step execution, now using AIProcessDataPointLinks for precise data mapping with TaskInstanceData.
Acceptance Criteria:
System correctly prepares input data for AI by fetching specified DataPoints from TaskInstanceData.
System correctly invokes AI handlers.
REVIEW_VALIDATION responses correctly drive step progression and log feedback.
OUTPUT_GENERATION responses are correctly parsed and stored into TaskInstanceData against the defined output DataPoints.
Robust error handling and logging are implemented.


Priority: Must Have
Standard/Reference: API Integration, Error Handling
REQ-AI-004
Requirement Type: Security
Description: If AI processes involve external services (AIProcesses.endpoint_url), communication MUST use HTTPS (TLS 1.2+). Authentication mechanisms (e.g., API Keys, OAuth 2.0 Client Credentials) MUST be used to secure calls to these external AI services. Sensitive data (PII) sent to external AI services MUST be minimized and subject to contractual agreements (e.g., BAAs if HIPAA applies) regarding data handling and privacy.
Rationale: Ensures secure communication and data protection when integrating with third-party AI services.
Acceptance Criteria:
HTTPS is enforced for all external AI service calls.
Appropriate authentication is implemented for external AI services.
Secrets (API keys) are managed securely (e.g., using a secrets manager, not hardcoded).
Data minimization principles are applied if PII is sent externally.


Priority: Must Have
Standard/Reference: OWASP A02:2021-Cryptographic Failures, OWASP A07:2021-Identification and Authentication Failures, Data Privacy Regulations (GDPR, HIPAA)
REQ-AI-005
Requirement Type: Auditing
Description: All invocations of AI processes MUST be audited. Audit logs MUST include:
Timestamp
TaskInstance ID
AIProcess ID invoked
Status (Success, Failure, Error)
A summary of input data (e.g., hash or non-sensitive identifiers)
A summary of output data or decision (e.g., Approved/Denied, hash of output, non-sensitive identifiers)
Duration of the AI process call.


Rationale: Provides a trail for understanding AI decision-making, performance, and troubleshooting integration issues.
Acceptance Criteria:
Audit log entries are created for each AI process invocation with all specified fields.
Logs are stored securely (as per REQ-AUDIT-001).


Priority: Must Have
Standard/Reference: OWASP A09:2021-Security Logging and Monitoring Failures


Module: Notifications (OneSignal Integration)
REQ-NOTIF-001
Requirement Type: Functional, Integration
Description: The system MUST integrate with OneSignal for sending push notifications to client (Flutter) applications and potentially web notifications for team members using a web interface (if applicable in the future).
Rationale: Provides a mechanism for real-time alerting of users about important events.
Acceptance Criteria:
OneSignal SDK is integrated into the Flutter client application.
Backend server is configured to use the OneSignal REST API (App ID, REST API Key).
Client application successfully registers devices with OneSignal and obtains a OneSignal Player ID.


Priority: Must Have
Standard/Reference: OneSignal Documentation
REQ-NOTIF-002
Requirement Type: Data
Description: The Users table (REQ-USER-001) MUST be extended to store the OneSignal Player ID associated with each user's active device(s). A user might have multiple devices, so this may require a separate UserDevicePlayerIDs table:
id (Primary Key)
user_id (FK to Users, NOT NULL)
player_id (VARCHAR, OneSignal Player ID, Unique, Indexed)
device_type (Enum: 'IOS', 'ANDROID', 'WEB', etc.)
last_seen_at (Timestamp)
is_active (Boolean, default: true)


Rationale: Allows the backend to target notifications to specific users via their OneSignal Player IDs.
Acceptance Criteria:
Database schema includes UserDevicePlayerIDs (or similar structure on Users if only one active device per user is assumed initially).
Client application, upon successful login and OneSignal registration, sends the Player ID to the backend to be stored against the user's record. An API endpoint (POST /users/me/devices) must exist for this.


Priority: Must Have
Standard/Reference: Data Modeling
REQ-NOTIF-003
Requirement Type: Functional, Server-Side Logic
Description: The backend system MUST trigger push notifications via OneSignal for the following critical events related to TaskInstances:
To Client:
When a task assigned to them transitions to OPEN.
When a task they submitted is RETURNED_TO_CLIENT (includes reason/feedback summary).
When a petition they own is COMPILED.
When a petition they own has a PetitionInstanceFilingProgress step updated.
When a new comment is added by a team member to one of their tasks.


To Assigned Team Member (NN/Vendor Employee/Manager):
When a task is assigned to them and becomes OPEN or PENDING_REVIEW.
When a task assigned to them is approaching its due_date (e.g., 24 hours before).
When a client adds a comment to a task assigned to them.


To Team Manager (if applicable, for unassigned team tasks):
When a task assigned to their team (but not a specific user) becomes OPEN or PENDING_REVIEW.




Rationale: Keeps users informed about actions requiring their attention or important status changes.
Acceptance Criteria:
Backend logic correctly identifies target users (and their Player IDs) for each event.
Notifications are successfully sent via OneSignal API for all specified events.
Notification content is clear, concise, and relevant to the event.
Notifications include deep-linking information (e.g., petition_instance_id, task_instance_id) to allow the client app to navigate to the relevant screen upon opening the notification.


Priority: Must Have
Standard/Reference: -
REQ-NOTIF-004
Requirement Type: Functional
Description: Notification message templates MUST be stored as ContentBlocks records (e.g., content_type = 'PLAIN_TEXT_TEMPLATE' or 'HTML_EMAIL_TEMPLATE'). These templates can include placeholders (e.g., {{taskName}}, {{clientName}}) that the backend populates with dynamic data before sending the notification. This allows for easier management, updating, and future localization of notification content.
Rationale: Standardizes template management using ContentBlocks for consistency.
Acceptance Criteria:
Notification message templates are stored as ContentBlocks.
Backend system retrieves these templates, populates placeholders, and uses the result for OneSignal payloads.


Priority: Should Have
Standard/Reference: Content Management
REQ-NOTIF-005
Requirement Type: Functional, Client-Side Logic
Description: The client application (Flutter) MUST correctly handle received push notifications:
Display the notification to the user (system tray).
When a user taps on a notification, the app MUST navigate to the relevant context (e.g., specific task screen, petition dashboard) based on data included in the notification payload.
Optionally, update in-app badges or indicators based on unread notifications.


Rationale: Ensures notifications are actionable and provide a good user experience.
Acceptance Criteria:
Client app displays notifications.
Deep-linking from notifications to specific app sections functions correctly.


Priority: Must Have
Standard/Reference: Mobile App UX Best Practices
REQ-NOTIF-006
Requirement Type: Functional
Description: Users (Clients and Team Members) MUST have settings within the application to manage their notification preferences (e.g., enable/disable certain types of notifications), where legally permissible and practical.
Rationale: Gives users control over the notifications they receive, improving user satisfaction.
Acceptance Criteria:
User profile includes settings for notification preferences.
Backend respects these preferences when deciding whether to send a notification to a user (by not sending or by using OneSignal segments/tags if user has opted out of specific types).


Priority: Should Have
Standard/Reference: User Preferences Management
REQ-NOTIF-007
Requirement Type: Security
Description: OneSignal REST API Key and App ID MUST be stored securely on the backend (e.g., environment variables, secrets manager) and not exposed in client-side code or logs.
Rationale: Protects OneSignal credentials from unauthorized use.
Acceptance Criteria:
OneSignal credentials are not hardcoded or accessible from the client.
Secure storage mechanisms are used for these credentials on the server.


Priority: Must Have
Standard/Reference: OWASP A05:2021-Security Misconfiguration
REQ-NOTIF-008
Requirement Type: Auditing
Description: The sending of critical notifications (or at least the attempt to send) SHOULD be logged for troubleshooting purposes. Logs could include: Timestamp, Target User ID, Event Type, Notification Content Summary, OneSignal Send Status (Success/Failure).
Rationale: Aids in diagnosing notification delivery issues.
Acceptance Criteria:
Attempts to send key notifications are logged with relevant details.


Priority: Should Have
Standard/Reference: Logging Best Practices
REQ-NOTIF-009: Notification Center & Persistent Storage
Requirement Type: Functional, Data, API, UI
Description:
Persistent Storage: The system MUST store a persistent record of important notifications sent to users in a UserNotifications table. Each record MUST include:
id (Primary Key, UUID recommended)
user_id (UUID, FK to Users.id, NOT NULL, Indexed)
title (TEXT, Short title of the notification, NOT NULL)
message (TEXT, Full notification message, NOT NULL)
notification_type (Enum: 'TASK_ASSIGNED', 'TASK_STATUS_CHANGED', 'TASK_COMMENT_ADDED', 'TASK_REMINDER', 'PETITION_STATUS_CHANGED', 'FILING_UPDATE', 'GENERAL_ALERT', 'ADDON_CONFIRMATION', 'UPGRADE_CONFIRMATION', NOT NULL)
read_status (Boolean, default: false, NOT NULL, Indexed)
deep_link_target_type (Enum: 'PETITION', 'TASK', 'COMMENT_THREAD', 'FILING_STEP', Nullable) - Entity type for deep-linking.
deep_link_target_id (UUID, Nullable) - ID of the entity for deep-linking.
related_entity_type (Enum: 'PETITION_INSTANCE', 'TASK_INSTANCE', etc., Nullable) - Broader context.
related_entity_id (UUID, Nullable) - ID of the broader context entity.
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())


Creation: When a server-side event triggers a push notification (as per REQ-NOTIF-003), if the event is deemed significant for persistent history (e.g., not just transient reminders unless desired), a corresponding record MUST also be created in UserNotifications for each target user.
Notification Center UI: The client application MUST provide a "Notification Center" screen (as per mockup). This screen MUST:
Display a list of the user's notifications retrieved from UserNotifications, ordered by created_at descending.
Visually differentiate between read and unread notifications.
Allow filtering by "All" and "Unread".
Implement "Mark all as read" functionality.
Allow tapping on a notification to mark it as read and, if deep_link_target_type and deep_link_target_id are present, navigate the user to the relevant in-app screen/entity .


API Endpoints:
GET /users/me/notifications: Retrieve user's notifications. Supports pagination and filtering by read_status.
PATCH /users/me/notifications/{notificationId}/mark-read: Mark a specific notification as read.
POST /users/me/notifications/mark-all-read: Mark all unread notifications for the user as read.




Rationale: Provides a persistent, in-app history of important notifications, ensuring users don't miss critical updates even if they dismiss push alerts. Supports the "Notification Center Screen" mockup.
Acceptance Criteria:
UserNotifications table schema exists with specified fields and enums.
Persistent notifications are created in UserNotifications for designated important events that also trigger push notifications.
Client UI for Notification Center displays notifications, supports filtering, mark as read (single/all), and deep-linking.
API endpoints for retrieving and managing read status exist, function correctly, are authorized, and documented in OAS.


Priority: Must Have
Standard/Reference: User Experience Best Practices, Mobile App Design Patterns, OAS 3.x

Module: System Security & Compliance
General Security Principles:
Defense in Depth: Implement multiple layers of security controls.
Principle of Least Privilege: Users and system components should only have the permissions necessary to perform their intended functions.
Secure by Default: Configure systems and applications with secure settings out-of-the-box.
Fail Securely: If a system or component fails, it should do so in a way that maintains security.

A01:2021 – Broken Access Control (Consolidated & Detailed)
REQ-SEC-BAC-001
Requirement Type: Security
Description: The system MUST implement robust server-side authorization checks for every API endpoint based on the authenticated user's role (CLIENT, VENDOR_EMPLOYEE, etc.) and relevant attributes (e.g., company_id, team_id, resource ownership, is_lawyer). All authorization decisions MUST be enforced on the server. (Cross-references REQ-AUTHZ-001, REQ-AUTHZ-002, REQ-AUTHZ-003).
Rationale: Prevents users from accessing unauthorized data or functionality by bypassing client-side controls or manipulating requests.
Acceptance Criteria:
For every API endpoint, clear authorization rules are defined and implemented server-side.
Penetration testing and code reviews verify that users cannot perform actions or access data outside their defined permissions.
Attempts to access unauthorized resources result in HTTP 403 Forbidden.


Priority: Must Have
Standard/Reference: OWASP A01:2021
REQ-SEC-BAC-002
Requirement Type: Security
Description: API endpoints that operate on specific resources (e.g., /v1/tasks/{taskInstanceId}, /v1/petitions/{petitionInstanceId}) MUST verify that the authenticated user has the right to access/modify that specific instance of the resource, in addition to role-based checks. (e.g., a client can only access their own petitions).
Rationale: Prevents insecure direct object references (IDOR) where a user could potentially access another user's data by guessing resource IDs.
Acceptance Criteria:
Ownership or explicit permission checks for specific resource instances are implemented for all relevant endpoints.
Testing verifies that users cannot access or modify resources not belonging to them or not explicitly shared/assigned.


Priority: Must Have
Standard/Reference: OWASP A01:2021 (IDOR)
REQ-SEC-BAC-003
Requirement Type: Security
Description: The system MUST enforce Cross-Origin Resource Sharing (CORS) policies on the server-side to restrict which origins are allowed to make requests to the API. Policies should be as restrictive as possible (e.g., allowing only the known client application domains/origins).
Rationale: Mitigates risks associated with cross-domain request forgery and unauthorized data access from malicious websites.
Acceptance Criteria:
CORS headers (e.g., Access-Control-Allow-Origin) are correctly configured on the server.
Policy only allows expected client origins. Wildcard origins (*) should be avoided for sensitive APIs.


Priority: Must Have
Standard/Reference: OWASP A01:2021, W3C CORS Specification

A02:2021 – Cryptographic Failures (Consolidated & Detailed)
REQ-SEC-CRYPTO-001 (Data in Transit)
Requirement Type: Security
Description: All communication channels between the client application and the backend server, between the server and external services (Auth0, OneSignal, Payment Gateway, AI Services), and between server components (if applicable) MUST use HTTPS enforced with TLS 1.2 or higher. Older TLS/SSL versions (TLS 1.1, 1.0, SSLv3) MUST be disabled.
Rationale: Protects data confidentiality and integrity during transmission against eavesdropping and tampering.
Acceptance Criteria:
Server is configured to only accept TLS 1.2+ connections.
Valid, trusted SSL/TLS certificates are used.
Automated scans (e.g., SSL Labs) confirm strong TLS configuration.


Priority: Must Have
Standard/Reference: OWASP A02:2021, PCI DSS, HIPAA
REQ-SEC-CRYPTO-002 (Data at Rest - PII & Documents)
Requirement Type: Security
Description:
All PII fields within specific tables (e.g., Users.email, Users.first_name) MUST be encrypted at rest using AES-256 (or equivalent strong algorithm).
Data stored in TaskInstanceData.value_* columns MUST be encrypted at rest if the corresponding DataPoints.is_pii flag for its data_point_id is true.
All uploaded documents (legal documents, evidence files) MUST be encrypted at rest in object storage (REQ-FMAN-002).
Key management MUST follow REQ-SEC-CRYPTO-003.


Rationale: Protects sensitive data, including dynamic data collected in tasks, based on its PII classification in DataPoints.
Acceptance Criteria:
Specified PII fields in tables like Users are encrypted.
Values in TaskInstanceData linked to PII DataPoints are encrypted.
Object storage encryption is enabled.
Application can decrypt for authorized use.


Priority: Must Have
Standard/Reference: OWASP A02:2021, GDPR Art. 32
REQ-SEC-CRYPTO-003 (Key Management)
Requirement Type: Security
Description: Cryptographic keys used for data-at-rest encryption (database field encryption, document encryption if using client-side or application-level encryption) MUST be managed securely. This includes:
Using a dedicated Key Management Service (KMS) (e.g., AWS KMS, Azure Key Vault, HashiCorp Vault) where possible.
Strong key generation and regular key rotation policies.
Strict access controls to the KMS and keys.
Never hardcoding keys in application code or configuration files.


Rationale: Protects the keys that protect the data. Compromise of keys renders encryption useless.
Acceptance Criteria:
Key management strategy is documented and implemented.
KMS is used if feasible.
Keys are not present in source code or unencrypted configuration.
Key rotation procedures are defined.


Priority: Must Have
Standard/Reference: OWASP A02:2021, NIST SP 800-57
REQ-SEC-CRYPTO-004 (Hashing Passwords - Auth0 Handled)
Requirement Type: Security
Description: User passwords MUST NOT be stored by the application. Authentication is delegated to Auth0, which is responsible for securely hashing and storing password credentials.
Rationale: Application avoids the significant risk and complexity of managing user passwords directly.
Acceptance Criteria:
Application does not store or handle user passwords directly.
Auth0 integration handles all password-related operations.


Priority: Must Have
Standard/Reference: OWASP A02:2021 (Related to not storing secrets insecurely)

A03:2021 – Injection (Consolidated & Detailed)
REQ-SEC-INJECT-001 (Input Validation)
Requirement Type: Security
Description: All input data received by the server (URL path parameters, query parameters, request headers, request bodies) MUST be rigorously validated on the server-side before being processed or stored. Validation MUST include:
Type checking: Based on DataPoints.data_type and OAS schema definitions.
Structural validation: Adherence to JSON Schema for request bodies (see REQ-SEC-INJECT-003).
Specific constraints: Using DataPoints.validation_rules (e.g., regex, min/max length/value).
Allow-list validation: For parameters with a known set of allowed values (e.g., enums).
Output Encoding/Sanitization: Before rendering any user-supplied data back to a client (especially in web contexts if a web admin panel is built), data MUST be contextually encoded (e.g., HTML entity encoding, JavaScript encoding) to prevent Cross-Site Scripting (XSS). For data used in other contexts (e.g., constructing OS commands - AVOID), proper escaping is critical.


Rationale: Prevents injection flaws by ensuring data conforms to expected patterns and by neutralizing malicious payloads for various contexts.
Acceptance Criteria:
Server-side input validation is implemented for all API endpoints using a consistent framework (e.g., integrating with OAS schema validation, custom validators using DataPoints metadata).
Invalid input results in HTTP 400 Bad Request or 422 Unprocessable Entity with clear, non-sensitive error messages.
Contextual output encoding is applied if data is reflected in UIs served by the backend.
Penetration testing specifically targets injection vulnerabilities.


Priority: Must Have
Standard/Reference: OWASP A03:2021, OWASP XSS Prevention Cheat Sheet


REQ-SEC-INJECT-002 (Parameterized Queries / ORM)
Requirement Type: Security
Description: All database queries that involve user-supplied data MUST use parameterized queries (prepared statements) or an Object-Relational Mapper (ORM) / Object-Document Mapper (ODM) that inherently uses parameterized queries. Dynamic query construction with string concatenation of user input is strictly forbidden.
Rationale: Primary defense against SQL Injection (SQLi) and NoSQL Injection vulnerabilities.
Acceptance Criteria:
Code review confirms no direct string concatenation of user input into database queries.
ORM/ODM or parameterized query libraries are used consistently for all database interactions.


Priority: Must Have
Standard/Reference: OWASP A03:2021 (SQLi)
REQ-SEC-INJECT-003 (JSON Schema Validation)
Requirement Type: Security, API
Description: The structure and data types of API request and response payloads (JSON) MUST be defined using JSON Schema. The server MUST validate incoming request bodies against their defined JSON Schema (as part of REQ-SEC-INJECT-001).
Rationale: Ensures structural integrity of data and provides a clear contract for API interactions, aiding in early rejection of malformed requests. Aligns with OpenAPI specification.
Acceptance Criteria:
JSON Schemas are defined for all API request/response bodies in the OAS document.
Server-side validation against these schemas is performed.


Priority: Must Have
Standard/Reference: JSON Schema, OAS 3.x, OWASP A03:2021 (Data validation aspect)

A04:2021 – Insecure Design (High-Level Principle)
REQ-SEC-DESIGN-001
Requirement Type: Security
Description: The system design MUST incorporate threat modeling during the design and development phases to identify potential threats, vulnerabilities, and required mitigations. Security considerations MUST be integrated throughout the entire software development lifecycle (SDL).
Rationale: Proactively addresses security risks from the outset rather than treating security as an afterthought.
Acceptance Criteria:
Evidence of threat modeling activities (e.g., diagrams, identified threats, planned mitigations).
Security requirements are reviewed and updated as the design evolves.


Priority: Must Have
Standard/Reference: OWASP A04:2021, Microsoft SDL

A05:2021 – Security Misconfiguration (Consolidated & Detailed)
REQ-SEC-MISCONF-001 (Secure Headers)
Requirement Type: Security
Description: The backend server MUST set appropriate HTTP security headers in responses to the client to protect against common web vulnerabilities. These include, but are not limited to:
Strict-Transport-Security (HSTS): Enforces HTTPS.
Content-Security-Policy (CSP): Prevents XSS by restricting sources of content.
X-Content-Type-Options: nosniff: Prevents MIME-sniffing attacks.
X-Frame-Options: DENY or SAMEORIGIN: Protects against clickjacking.
Referrer-Policy: strict-origin-when-cross-origin or similar.
Permissions-Policy (formerly Feature-Policy): Controls browser feature access.


Rationale: Hardens the client-side against various attacks by leveraging browser-based security mechanisms.
Acceptance Criteria:
Server responses include the specified security headers with appropriate, restrictive configurations.
Headers are verified using browser developer tools or security scanning tools.


Priority: Must Have
Standard/Reference: OWASP A05:2021, MDN Web Docs for each header
REQ-SEC-MISCONF-002 (Disable Unnecessary Features/Services)
Requirement Type: Security
Description: All unnecessary features, services, ports, protocols, and default accounts MUST be disabled or removed from the server environment and application dependencies. Verbose error messages revealing backend details MUST be disabled in production environments.
Rationale: Reduces the attack surface of the system.
Acceptance Criteria:
Server hardening procedures are documented and applied.
Application frameworks are configured to not reveal sensitive error details in production.
Regular reviews of enabled services and open ports.


Priority: Must Have
Standard/Reference: OWASP A05:2021, CIS Benchmarks
REQ-SEC-MISCONF-003 (Dependency Management)
Requirement Type: Security
Description: A process MUST be in place to regularly scan and update third-party libraries and dependencies (both client and server-side) for known vulnerabilities. Outdated or vulnerable components MUST be patched or replaced promptly.
Rationale: Addresses vulnerabilities in reusable components (OWASP A06:2021 - Vulnerable and Outdated Components).
Acceptance Criteria:
Tools for dependency scanning (e.g., npm audit, Snyk, OWASP Dependency-Check) are integrated into the CI/CD pipeline.
A policy for addressing identified vulnerable dependencies is defined and followed.


Priority: Must Have
Standard/Reference: OWASP A06:2021 (Covered here as it's often a misconfiguration to use outdated parts)

A07:2021 – Identification and Authentication Failures (Auth0 Focused)
REQ-SEC-AUTHN-001 (Auth0 Integration Security)
Requirement Type: Security
Description: The integration with Auth0 MUST follow security best practices:
Use Authorization Code Flow with PKCE for client authentication (REQ-AUTH-001).
Securely store client secrets (if applicable for any backend Auth0 interactions, e.g., Management API) using a secrets manager.
Regularly review Auth0 tenant security settings (MFA policies, brute-force protection, breached password detection).
Validate JWTs correctly on the backend (issuer, audience, signature, expiration) (REQ-AUTH-002).
Implement secure session management and logout (REQ-AUTH-004).


Rationale: Ensures the third-party identity provider is used securely.
Acceptance Criteria:
Auth0 configuration adheres to its security recommendations.
JWT validation is comprehensive.
Client-side token storage and handling are secure.


Priority: Must Have
Standard/Reference: OWASP A07:2021, Auth0 Documentation

A08:2021 – Software and Data Integrity Failures (File Uploads)
REQ-SEC-INTEGRITY-001 (Secure File Uploads)
Requirement Type: Security, File Management
Description: The system MUST implement secure file upload mechanisms:
Validate file types using an allow-list of permitted extensions and MIME types (server-side).
Enforce maximum file size limits.
Scan uploaded files for malware/viruses before storing or processing them.
Store uploaded files in a designated, non-executable location separate from application code (e.g., dedicated object storage).
Generate and store a cryptographic hash (e.g., SHA-256) of uploaded files on upload and verify this hash on download to ensure integrity. (See REQ-FMAN-003)


Rationale: Prevents attacks via malicious file uploads (e.g., webshells, malware). Ensures file integrity.
Acceptance Criteria:
File type, size, and virus scan validations are performed server-side.
Files are stored securely. Hash generation and verification implemented.
Attempting to upload disallowed file types or oversized files is rejected.


Priority: Must Have
Standard/Reference: OWASP A08:2021, OWASP File Upload Cheat Sheet

A09:2021 – Security Logging and Monitoring Failures (Consolidated Auditing)
REQ-SEC-AUDIT-001 (Comprehensive Audit Logging)
Requirement Type: Security, Auditing
Description: The system MUST implement comprehensive audit logging for security-relevant events. Logs MUST be detailed enough to reconstruct events and identify potential misuse. Key events to log include:
Authentication & Session Management: Logins (success/failure), logouts, password reset attempts (via Auth0), significant token validation failures (REQ-AUTH-003).
Authorization: Significant or repeated authorization failures (attempts to access forbidden resources or perform unauthorized actions).
User & Company Administration: User creation/invitation, role changes, status changes (activation/deactivation), is_lawyer status changes. Company creation, status changes (approval, rejection, suspension). Vendor billing plan changes. (Partially covered by original REQ-AUDIT-001).
Team Management: Team creation, owner changes, category changes, member additions/removals, team deactivation.
Petition Template Management: Template creation, publishing, archiving, versioning. Changes to critical components like plans, criteria, or graph definitions.
Petition Instance & Task Management: Petition creation, status changes (e.g., to 'COMPILED', 'FILED'). Task creation, assignment/reassignment, significant status changes (e.g., 'COMPLETED', 'RETURNED_TO_CLIENT', 'CANCELED'). Task upgrades, Add-on purchases.
Data Access & Modification (Critical Data):
File Management: Upload, download, deletion of any file (REQ-FMAN-007).
Access to or export of data from TaskInstanceData where the associated DataPoints.is_pii is true, particularly if unmasked. If PII data is included in log details, it MUST be masked or only non-sensitive identifiers logged.


AI Process Invocations: (REQ-AI-005).
System & Security Events: Key configuration changes, security policy violations, startup/shutdown of critical services, errors from security components.
Each log entry MUST include: Timestamp (UTC, synchronized across system components), Performing User ID (or system process ID), Authenticated User Role (if applicable), Source IP Address, Action Performed (standardized event type), Target Resource Type & ID (if applicable), Outcome (Success/Failure), and any relevant descriptive details or error codes.


Rationale: Enables detection of suspicious activity, supports incident response and forensic analysis, provides accountability, and is often required for compliance.
Acceptance Criteria:
All specified categories of events are logged with the required level of detail.
Audit logs are written to a secure, central, and tamper-evident storage (e.g., dedicated log management system like ELK/Splunk, or cloud provider solution like AWS CloudTrail/CloudWatch Logs with write-only S3 bucket, versioning, and MFA delete).
Logs are protected from unauthorized access, modification, or deletion.
Logs are retained according to a defined policy that meets legal, regulatory, and business requirements.
Log format is consistent and parsable.


Priority: Must Have
Standard/Reference: OWASP A09:2021, NIST SP 800-92, GDPR Art. 30 & 32, CCPA, HIPAA
REQ-SEC-AUDIT-002 (Log Monitoring & Alerting)
Requirement Type: Security, Monitoring
Description: A process or system MUST be in place to regularly review and monitor security logs for suspicious activities or anomalies. Automated alerts SHOULD be configured for high-severity security events (e.g., multiple failed logins for an account, privilege escalation attempts).
Rationale: Ensures that logs are not just collected but actively used to detect and respond to potential security incidents.
Acceptance Criteria:
A log monitoring solution (e.g., ELK stack, Splunk, AWS CloudWatch Logs with Alarms) is implemented.
Alerting rules are defined for critical security events.
Procedures for responding to alerts are documented.


Priority: Should Have (Must Have for high-security environments)
Standard/Reference: OWASP A09:2021

A10:2021 – Server-Side Request Forgery (SSRF)
REQ-SEC-SSRF-001 (Protect Against SSRF)
Requirement Type: Security
Description: If the application makes server-side requests to URLs provided or influenced by user input (e.g., webhook URLs, AI service endpoints if configurable by users which is NOT currently the case but good to note), it MUST implement defenses against SSRF. This includes:
Validating any user-supplied URL against an allow-list of permitted domains/IPs and schemes (e.g., only HTTPS to known hosts).
Avoiding direct use of user input in request URLs.
Using network controls (e.g., firewalls) to limit server outbound connectivity.


Rationale: Prevents attackers from forcing the server to make unintended requests to internal or external services. Current design (AI endpoints centrally managed) limits this risk, but this is a general best practice.
Acceptance Criteria:
If user-influenced URLs are ever introduced, SSRF protections are implemented and verified.
Server outbound network access is restricted to only necessary services.


Priority: Should Have (Becomes Must Have if user-controlled URLs are used)
Standard/Reference: OWASP A10:2021, OWASP SSRF Cheat Sheet

Compliance & Data Privacy (General)
REQ-SEC-COMPL-001
Requirement Type: Compliance, Legal
Description: The system design and operation MUST consider and adhere to relevant data privacy and security regulations (e.g., GDPR if EU residents' data is processed, CCPA if California residents, HIPAA if health information is involved, specific legal profession data handling rules for Arizona/US). This includes principles like data minimization, purpose limitation, user consent (if applicable beyond terms of service for specific data uses), data subject rights (access, rectification, erasure), breach notification procedures.
Rationale: Ensures legal and regulatory compliance.
Acceptance Criteria:
A Data Privacy Impact Assessment (DPIA) is conducted if required by regulations.
Mechanisms to support data subject rights are designed (e.g., data export, account deletion that properly handles data).
Privacy policy and terms of service accurately reflect data handling practices.


Priority: Must Have
Standard/Reference: GDPR, CCPA, HIPAA (as applicable), local legal ethics rules.

Module: Secure File Management
REQ-FMAN-001 (Secure File Upload Process)
Requirement Type: File Management, Security, API
Description: The system MUST provide a secure mechanism for clients and authorized team members to upload files (documents, evidence). This process MUST include:
Client-Side Pre-validation (Optional but Recommended): Client application SHOULD perform basic checks for file size and type (based on DataPoints.data_type attributes like allowed MIME types/extensions) before initiating upload to improve UX, but server-side validation is paramount.
API Endpoint: A dedicated API endpoint (e.g., POST /v1/files/upload) MUST handle file uploads. This endpoint MUST be authenticated and authorized.
Server-Side Validation (Mandatory):
File Type Validation: Validate file types using an allow-list of permitted MIME types and extensions (e.g., PDF, DOCX, JPEG, PNG). Reject disallowed types. Do not rely solely on client-provided Content-Type header; inspect file signatures if possible.
File Size Validation: Enforce a configurable maximum file size limit (e.g., 10MB, 25MB per file). Reject oversized files.
Filename Sanitization: Sanitize uploaded filenames to remove or replace potentially harmful characters (e.g., ../, null bytes, control characters) before using them in any storage path. Generate a unique, non-guessable internal filename for storage.


Virus Scanning: All uploaded files MUST be scanned for malware/viruses by an integrated antivirus engine before being persisted to permanent storage or made accessible. Files failing the scan MUST be rejected or quarantined, and the user notified.
Temporary Storage: Files MAY be temporarily stored during upload processing (e.g., during virus scan) in a secure, isolated location. This temporary storage must be cleaned up promptly after processing.


Rationale: Ensures only valid, safe files are accepted into the system, protecting against malware, denial-of-service from large files, and path traversal/injection attacks via filenames. Aligns with REQ-SEC-INTEGRITY-001.
Acceptance Criteria:
API endpoint for file upload exists, is authenticated and authorized.
Server-side validation for file type (allow-list), size, and filename sanitization is implemented and effective.
Virus scanning is integrated and effectively blocks/quarantines infected files.
Attempts to upload invalid/malicious files are rejected with appropriate error messages.
Endpoint documented in OAS, specifying multipart/form-data and expected fields.


Priority: Must Have
Standard/Reference: OWASP File Upload Cheat Sheet, OWASP A08:2021-Software and Data Integrity Failures
REQ-FMAN-002 (Secure File Storage)
Requirement Type: File Management, Security
Description: All uploaded files (documents, evidence, compiled petitions) and system-generated files (e.g., final PDF petitions) MUST be stored securely in a dedicated, robust object storage service (e.g., AWS S3, Azure Blob Storage). Storage MUST:
Be in a private, non-publicly accessible bucket/container.
Have Server-Side Encryption (SSE) enabled using strong encryption (e.g., AES-256), preferably with service-managed keys (SSE-S3/SSE-Azure) or customer-managed keys via a KMS (SSE-KMS) for enhanced control (REQ-SEC-CRYPTO-002).
Use unique, non-guessable, system-generated object keys/names for stored files (derived from the sanitized upload or a UUID). Original user-provided filenames can be stored as metadata.
Implement versioning for files if overwrites are possible or if recovery from accidental deletion is required.
Have strict access controls (IAM policies, bucket policies) ensuring only authorized application roles/services can read/write files.


Rationale: Protects the confidentiality, integrity, and availability of stored documents.
Acceptance Criteria:
Files are stored in a designated private object storage service.
Server-side encryption (AES-256) is enabled and verified.
System-generated unique names are used for stored objects.
Access controls (IAM/bucket policies) are configured according to the principle of least privilege.
Versioning is enabled (if deemed necessary).


Priority: Must Have
Standard/Reference: OWASP Top 10 (various, re: data protection), Cloud Provider Security Best Practices
REQ-FMAN-003 (File Integrity)
Requirement Type: File Management, Security
Description: To ensure file integrity:
Upon successful upload (after virus scan and validation), the system MUST generate a cryptographic hash (e.g., SHA-256) of the file content.
This hash, along with original filename, MIME type, size, and upload timestamp, MUST be stored as metadata associated with the file (e.g., in the TaskInstanceData record for the corresponding FILE_REFERENCE DataPoint, or in a dedicated Files metadata table if files are managed more centrally).
Optionally, when a file is downloaded or accessed for processing (e.g., PDF compilation), its hash CAN be re-calculated and compared against the stored hash to detect corruption or tampering. (This can be computationally intensive).


Rationale: Provides a mechanism to verify that files have not been altered since they were uploaded or generated. Builds on REQ-SEC-INTEGRITY-001.
Acceptance Criteria:
SHA-256 (or stronger) hash is generated for every uploaded/generated file.
Hash and other metadata are stored securely alongside the file reference.
(Optional) Integrity check on download/access is considered/implemented where critical.


Priority: Must Have (for hash generation/storage), Should Have (for check on download)
Standard/Reference: NIST SP 800-107 (Recommendation for Applications Using Approved Hash Algorithms)
REQ-FMAN-004 (Secure File Access & Download)
Requirement Type: File Management, Security, API
Description: The system MUST provide a secure mechanism for authorized users to download files associated with their petitions or tasks.
Direct public URLs to files in object storage MUST NOT be used.
An API endpoint (e.g., GET /v1/files/{fileId}/download or GET /v1/tasks/{taskInstanceId}/data/{dataPointId}/file?instanceIndex=0) MUST gate access to files.
This endpoint MUST perform robust authentication and authorization checks to ensure the user has permission to access the specific file (based on petition ownership, task assignment, document visibility rules from REQ-SEC-BAC-001 & REQ-SEC-BAC-002).
The API endpoint can either:
Stream the file directly from object storage through the server.
Generate a short-lived, pre-signed URL for the object storage service, allowing the client to download directly from object storage temporarily. This is generally preferred for performance and reducing server load.


Appropriate Content-Disposition: attachment; filename="user_friendly_name.ext" and Content-Type headers MUST be set in the download response.


Rationale: Ensures only authorized users can access specific files, preventing direct unauthorized access to the storage layer. Pre-signed URLs offer a good balance of security and performance.
Acceptance Criteria:
File download API endpoint exists, is authenticated and authorized.
Authorization logic correctly verifies user's permission for the specific file.
Pre-signed URLs (if used) are short-lived and correctly generated.
Appropriate HTTP headers for download are set.
Files cannot be accessed via direct, persistent URLs to object storage.
Endpoint documented in OAS.


Priority: Must Have
Standard/Reference: OWASP A01:2021-Broken Access Control, Cloud Provider Pre-signed URL documentation
REQ-FMAN-005 (File Metadata Storage)
Requirement Type: File Management, Data
Description: The system MUST store comprehensive metadata for every uploaded or system-generated file in a central Files table. When a DataPoint of type FILE_REFERENCE is used, the corresponding TaskInstanceData.value_file_reference field MUST store the file_id (FK to Files.id). When a DataPoint of type ARRAY_OF_FILES is used, TaskInstanceData.value_file_array_reference MUST store a JSON array of file_ids. The Files table MUST include:
file_id (Primary Key, UUID recommended)
original_filename (TEXT, User-provided filename, sanitized, NOT NULL)
stored_object_key (TEXT, Unique key/path used in the object storage, NOT NULL)
mime_type (VARCHAR, Detected MIME type, NOT NULL)
size_bytes (BIGINT, File size in bytes, NOT NULL)
sha256_hash (CHAR(64), Hex-encoded SHA-256 hash of the file content, NOT NULL, Indexed)
storage_bucket_name (TEXT, Name of the object storage bucket, NOT NULL)
uploaded_by_user_id (UUID, FK to Users.id, NOT NULL)
upload_timestamp (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
virus_scan_status (Enum: 'PENDING', 'CLEAN', 'INFECTED', 'ERROR', 'SKIPPED', NOT NULL)
virus_scan_details (TEXT, Nullable)
access_tier (Enum: 'STANDARD', 'ARCHIVAL', Nullable)
deletion_status (Enum: 'ACTIVE', 'PENDING_DELETION', 'DELETED', default: 'ACTIVE', NOT NULL)
created_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
updated_at (TIMESTAMP WITH TIME ZONE, NOT NULL, default: now())
(Optional Context Links - consider if needed or if queries will join through TaskInstanceData)
_context_petition_instance_id (UUID, FK to PetitionInstances.id, Nullable, Indexed for faster global file searches per petition)
_context_task_instance_id (UUID, FK to TaskInstances.id, Nullable, Indexed for faster file searches per task)




Rationale: Provides a central, auditable, detailed record for every file. TaskInstanceData links to these records. Context links are for optimized querying.
Acceptance Criteria:
Database schema includes Files table.
TaskInstanceData fields for file references store file_id(s).
File upload process (REQ-FMAN-001) creates entries in Files.


Priority: Must Have
Standard/Reference: Data Modeling, Digital Asset Management
REQ-FMAN-006 (Document Retention & Disposal Policies)
Requirement Type: File Management, Compliance, Legal
Description: The system MUST support configurable document retention policies based on legal and business requirements (e.g., retain petition data for X years after case completion/closure). There MUST be a secure mechanism for the disposal (deletion) of documents and their associated metadata when their retention period expires. Deletion MUST be permanent and irrecoverable from primary storage.
Rationale: Ensures compliance with data retention laws and minimizes risk associated with holding data longer than necessary.
Acceptance Criteria:
Mechanism for defining retention policies (e.g., by PetitionTemplateType or globally) exists.
A scheduled process or manual trigger exists to identify documents eligible for disposal.
Secure deletion methods are used (e.g., object storage lifecycle policies for deletion, database record deletion).
Deletion actions are auditable.


Priority: Must Have (for legal compliance)
Standard/Reference: GDPR (Storage Limitation), CCPA, relevant legal record-keeping requirements.
REQ-FMAN-007 (Audit Trail for File Access)
Requirement Type: File Management, Auditing, Security
Description: All significant file access events MUST be audited (as per REQ-SEC-AUDIT-001). This includes:
File Upload (User ID, Timestamp, File ID/Name, Outcome)
File Download (User ID, Timestamp, File ID/Name)
File Deletion (User ID, Timestamp, File ID/Name, Trigger: Policy/Manual)
Failed access attempts to files.


Rationale: Provides a security trail for file handling, crucial for investigating breaches or unauthorized access.
Acceptance Criteria:
Specified file access events are logged with all necessary details (User ID, Timestamp, File ID, Action, Source IP).
Audit logs are stored securely and are tamper-evident.


Priority: Must Have
Standard/Reference: OWASP A09:2021-Security Logging and Monitoring Failures

REQ-PTMPL-LIST-001 (Client/Admin): List/Search Petition Templates
Requirement Type: Functional, API
Description: An API endpoint (GET /v1/petition-templates/published) MUST exist to list all PUBLISHED Petition Templates. It MUST support:
Filtering by petition_type_id, tag_ids.
Full-text search on name and description.
Pagination.
The response for each template should include id, name, description, petition_type_name, associated tag_names. For admins, more details like status might be included via a separate admin endpoint (GET /v1/petition-templates).


Rationale: Allows clients to discover available petitions and admins to manage templates.
Acceptance Criteria: Endpoint exists, implements filtering/search/pagination, returns specified data, documented in OAS.
Priority: Must Have
REQ-CLIENT-PETLIST-001 (Client): List/Filter Own Petitions
Requirement Type: Functional, API
Description: An API endpoint (GET /v1/client/petitions) MUST allow authenticated clients to retrieve a list of their own PetitionInstances. It MUST support:
Filtering by status (e.g., 'IN_PROGRESS', 'COMPLETED', 'FILED').
Filtering by date range (created_at).
Searching by petition name (derived from PetitionTemplate.name).
Pagination.


Rationale: Allows clients to view and manage their history of petitions.
Acceptance Criteria: Endpoint exists, correctly filters by current user, implements filtering/search/pagination, documented in OAS.
Priority: Must Have
REQ-CLIENT-TASKLIST-001 (Client): List/Filter Own Tasks
Requirement Type: Functional, API
Description: An API endpoint (GET /v1/client/tasks) MUST allow authenticated clients to retrieve a list of their own assigned TaskInstances across all their petitions. It MUST support:
Filtering by status.
Filtering by petition_instance_id.
Pagination.


Rationale: Allows clients to get an overview of all their tasks.
Acceptance Criteria: Endpoint exists, correctly filters by current user, implements filtering/pagination, documented in OAS.
Priority: Must Have

REQ-TEAM-TASKLIST-001 (Employee/Manager/Admin): List/Filter Team/Company Tasks
Requirement Type: Functional, API
Description: Enhance dashboard APIs or create specific endpoints (e.g., GET /v1/tasks/assigned-to-me, GET /v1/tasks/team/{teamId}, GET /v1/tasks/company/{companyId}) to allow Employees, Managers, and Admins to list and filter tasks based on their role and scope, including:
Filtering by status, assigned_user_id, assigned_team_id, petition_instance_id, due_date range.
Pagination.


Rationale: Supports advanced task searching beyond basic dashboard views for internal users.
Acceptance Criteria: Endpoints exist, implement role-based scoping and specified filters/pagination, documented in OAS.
Priority: Must Have

REQ-CLIENT-PETCREATE-001 (New - derived from flow): Accept T&Cs for Petition
Requirement Type: Functional, API
Description: When a client selects a plan and initiates petition creation (via POST /v1/petitions REQ-PETI-001, or a preceding step), the API request (or a separate confirmation step) MUST include an indicator that the client has accepted the terms_and_conditions_content associated with the selected PetitionTemplatePlan. The acceptance (user_id, plan_id, timestamp) MUST be logged.
Rationale: Captures client agreement to plan-specific T&Cs.
Acceptance Criteria: API for petition creation includes T&C acceptance. Acceptance is logged for audit.
Priority: Must Have

REQ-INTERNAL-PETLIST-001 (NEW - List/Filter Petitions for Internal Users)
Requirement Type: Functional, API
Description: An API endpoint (e.g., GET /v1/internal/petitions) MUST exist to allow authenticated internal users (Employees, Managers, Admins) to retrieve a list of PetitionInstances based on their role-defined scope and provided filters.
Authorization: The endpoint MUST enforce data scoping:
NN_EMPLOYEE/VENDOR_EMPLOYEE: Sees petitions where they are assigned to a task, or the petition is assigned to a team they are a member of.
NN_MANAGER/VENDOR_MANAGER: Sees petitions assigned to their team(s) or team members, plus their own assigned task-related petitions.
NN_ADMIN: Sees all petitions across all companies.
VENDOR_ADMIN: Sees all petitions within their own company.


Request Parameters (Query):
search_term (string, for free-text search)
status (array of strings, for PetitionInstance.status)
client_id (UUID)
assigned_team_id (UUID)
assigned_lead_employee_id (UUID)
template_type_id (UUID)
company_id (UUID, for NN_ADMIN)
date_created_start, date_created_end
date_updated_start, date_updated_end
sort_by (e.g., 'last_updated_at', 'client_name')
sort_direction ('asc', 'desc')
page (integer)
limit (integer)


Response: Paginated list of petition summaries, including fields necessary for the list view (Petition ID, Client Name, Template Name, Status, relevant counts, dates).


Rationale: Provides the data backbone for the internal "Petitions Management" screen, enabling powerful searching and filtering capabilities for staff.
Acceptance Criteria:
Endpoint exists and correctly implements role-based data scoping.
All specified search and filter parameters function correctly.
Pagination and sorting are implemented.
Response structure provides all necessary data for the UI.
Performance is optimized for querying large datasets.
Endpoint documented in OAS.


Priority: Must Have
