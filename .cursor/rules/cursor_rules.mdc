---
description: Guidelines for creating and maintaining Cursor rules to ensure consistency and effectiveness.
globs: .cursor/rules/*.mdc
alwaysApply: true
---
# National Niner Backend - Cursor Context Rules

This document provides the essential context and architectural rules for our backend project. Adhering to these principles is critical for maintaining code quality, consistency, and security.

## 1. Project Overview & Core Technologies

-   **Purpose:** A multi-tenant, service baporting a mobile application for mplex legal petition workflows.
-  * **NestJS** (TypeScript). This is a hard requirement. All code must follow NestJS conventions.
-   **Database:** **MySQL 8+**.
-   **ORM:** **Sequelize**. All database interaction MUST go through Sequelize models and its query interface. No raw SQL queries are permitted.
-   **Authentication:** **Auth0**. The backend validates JWTs issued by Auth0. A custom signup flow exists where the backend provisions users in Auth0 via the Management API.
-   **Authorization:** A hybrid **Role-Based Access Control (RBAC) + Permission** system. Roles are collections of fine-grained permissions. All authorization decisions are based on a user's *effective permissions*.
-   **Key Integrations:**
    -   **File Storage:** AWS S3
    -   **Payment Gateway:** Stripe (using the Payment Intents flow)
    -   **Push Notifications:** OneSignal
    -   **Virus Scanning:** ClamAV (via a separate containerized service)

## 2. Core Architectural Principles (The "NestJS Way")

Our architecture is built on the core principles of NestJS. Understanding this is the most important rule.

-   **Modularity is King (`*.module.ts`):** The application is divided into feature modules (e.g., `UsersModule`, `PetitionTemplateModule`). Each module should be as self-contained as possible, encapsulating its controllers, services, and providers. The `AppModule` is for wiring global modules together.

-   **Controllers are the "Traffic Cops" (`*.controller.ts`):**
    -   **Responsibility:** A controller's ONLY job is to handle the HTTP request/response layer. It defines routes, binds parameters (path, query, body), and calls a single method on a service.
    -   **STRICT RULE:** Controllers contain **NO business logic**. They should be very thin.
    -   **Example:** A controller method might parse the `userId` from the request and pass it to a service, but it will *not* decide *what to do* with that `userId`.

-   **Services are the "Brains" (`*.service.ts`):**
    -   **Responsibility:** ALL business logic, data validation (beyond simple type checks), database interactions (via Sequelize models), and calls to other services or external APIs reside here.
    -   Services are `@Injectable()` and provided by their module.
    -   **STRICT RULE:** Services should never directly interact with the HTTP `Request` or `Response` objects. They receive pure data from the controller and return data or throw exceptions.

-   **Dependency Injection:** Always use NestJS's DI system. Inject services into controllers, and other services into services, via their constructors.

## 3. Key Directory Structure & Purpose

-   `/src`
    -   `/main.ts`: Application entry point. Wires up global middleware, guards, and filters.
    -   `/app.module.ts`: The root module of the application.
    -   `/modules/{feature-name}/`: **This is where 90% of our code lives.** Each subdirectory is a self-contained feature module (e.g., `users`, `teams`, `petition-templates`).
        -   `/{feature-name}.module.ts`
        -   `/{feature-name}.controller.ts`
        -   `/{feature-name}.service.ts`
        -   `/dto/`: Contains all Data Transfer Objects for this module.
        -   `/entities/`: Contains the Sequelize model definition for this module.
    -   `/core/`: For cross-cutting concerns shared by all modules.
        -   `/guards/`: Global guards like `JwtAuthGuard` and `PermissionsGuard`.
        -   `/interceptors/`: Global interceptors like `AuditInterceptor`.
        -   `/filters/`: Global exception filters.
    -   `/database/`: For all database-related configuration.
        -   `/migrations/`: All Sequelize migration files, generated by `sequelize-cli`.
        -   `/seeders/`: All Sequelize seeder files.
        -   `/config.js`: The Sequelize CLI configuration file.

## 4. Critical Core Services & Abstractions

When asked to implement a feature, know that these core services likely already provide the tools you need.

-   `PermissionsService`: The single source of truth for a user's effective permissions. Use this service within guards to check for access.
-   `ConditionEvaluationService`: Securely evaluates rule strings (e.g., `(experience > 5)`) using the `jexl` library. Use this when implementing logic related to template conditions.
-   `TaskLifecycleService`: The state machine for `TaskInstances`. Manages status transitions (e.g., from `LOCKED` to `OPEN`) when prerequisites are met.
-   `PdfCompilationService`: An asynchronous service for generating the final petition PDF from templates and user-uploaded files.
-   `StripeService`: Encapsulates all interactions with the Stripe API.
-   `S3StorageService`: Encapsulates all interactions with AWS S3 for file storage.
-   `AuditService`: Provides a simple method to asynchronously log critical security and business events.

## 5. Coding Conventions & Best Practices

-   **DTOs (Data Transfer Objects):**
    -   Use DTOs for ALL request bodies and response payloads.
    -   Use the `class-validator` and `class-transformer` libraries extensively for validation and transformation.
    -   Follow a naming pattern: `CreateFeatureDto`, `UpdateFeatureDto`, `FeatureResponseDto`.
    -   Response DTOs should use the `@Expose()` decorator to explicitly define which fields are sent to the client, preventing data leakage.
-   **Error Handling:**
    -   **Services throw exceptions, controllers do not.**
    -   Use NestJS's built-in HTTP exceptions: `new NotFoundException('Team not found')`, `new ForbiddenException('Permission denied')`, `new UnprocessableEntityException('Cannot remove the last lawyer')`.
    -   A global filter (defined in `/core/filters`) catches these and formats the final HTTP response.
-   **Configuration:**
    -   Use the `@nestjs/config` module. All configuration and secrets MUST be loaded from environment variables (`.env` file for local development).
    -   **STRICT RULE:** No hardcoded API keys, secrets, or environment-specific URLs in the code.
-   **Constants:** Use enums or `const` objects for magic strings like roles, permissions, or statuses. Do not type `'PENDING_REVIEW'` directly in service logic.

## 6. Testing Strategy & TDD Guidelines

Our testing strategy follows the **Testing Pyramid** with clear separation between fast unit tests and comprehensive integration tests. **ALL NEW FEATURES MUST FOLLOW TDD** (Test-Driven Development).

### Test-Driven Development (TDD) Workflow

**MANDATORY PROCESS FOR ALL NEW FEATURES:**

1. **Red Phase:** Write a failing test first
2. **Green Phase:** Write minimal code to make the test pass
3. **Refactor Phase:** Improve code quality while keeping tests green
4. **Repeat:** Continue cycle for each small feature increment

### Test Organization & Architecture

We use a **hybrid testing strategy** optimized for developer productivity:

#### **Unit Tests (`*.spec.ts`) - FAST TESTS**
- **Location:** Co-located with source code in `src/` directory
- **Purpose:** Test individual components in isolation
- **Speed:** <100ms per test, <5 seconds total
- **Dependencies:** ALL external dependencies MUST be mocked using Jest
- **Run Command:** `npm test` (for rapid development feedback)
- **Coverage:** Focus on services, guards, DTOs, and utility functions

**Unit Test Requirements:**
```typescript
// Example: src/modules/teams/team.service.spec.ts
describe('TeamService', () => {
  let service: TeamService;
  let mockTeamRepository: jest.Mocked<typeof Team>;
  let mockUserRepository: jest.Mocked<typeof User>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        TeamService,
        { provide: getModelToken(Team), useValue: mockTeamRepository },
        { provide: getModelToken(User), useValue: mockUserRepository },
      ],
    }).compile();
    
    service = module.get<TeamService>(TeamService);
  });

  it('should create team with valid data', async () => {
    // Arrange
    const createTeamDto = { name: 'Legal Team', type: 'LEGAL' };
    mockTeamRepository.create.mockResolvedValue(mockTeam);
    
    // Act
    const result = await service.create(createTeamDto, mockUser);
    
    // Assert
    expect(result).toEqual(mockTeam);
    expect(mockTeamRepository.create).toHaveBeenCalledWith(expectedData);
  });
});
```

#### **Integration/E2E/Performance Tests - COMPREHENSIVE TESTS**
- **Location:** Centralized in `test/` directory organized by type
- **Purpose:** Test business workflows, database operations, security
- **Speed:** Slower, requires database/external services
- **Run Commands:** 
  - `npm run test:integration` - Integration tests only
  - `npm run test:e2e` - End-to-end tests only
  - `npm run test:all-slow` - All comprehensive tests

**Test Directory Structure:**
```
test/
├── database/           # Database constraints, migrations, integrity
├── security/           # Security testing, compliance validation  
├── performance/        # Performance benchmarks, load testing
├── e2e/               # End-to-end application testing
├── integration/       # Cross-service integration tests
├── entities/          # Entity validation testing
└── utils/             # Shared test utilities and helpers
```

### TDD Implementation Guidelines

#### **1. Writing Unit Tests (TDD Red-Green-Refactor)**

**BEFORE writing any service method:**

```typescript
// Step 1: RED - Write failing test first
describe('TeamService.validateTeamCreation', () => {
  it('should throw BadRequestException when team has no lawyers for LEGAL type', async () => {
    // Arrange
    const teamData = { name: 'Legal Team', type: 'LEGAL', members: [] };
    
    // Act & Assert
    await expect(service.validateTeamCreation(teamData))
      .rejects.toThrow(BadRequestException);
  });
});

// Step 2: GREEN - Write minimal implementation
async validateTeamCreation(teamData: CreateTeamDto): Promise<void> {
  if (teamData.type === 'LEGAL' && teamData.members.length === 0) {
    throw new BadRequestException('Legal teams must have at least one lawyer');
  }
}

// Step 3: REFACTOR - Improve while keeping tests green
```

#### **2. Integration Test Patterns**

**For complex business workflows:**

```typescript
// test/integration/team-creation.integration.spec.ts
describe('Team Creation Workflow', () => {
  beforeEach(async () => {
    await TestDatabaseHelper.cleanDatabase();
    await TestDatabaseHelper.seedBasicData();
  });

  it('should complete full team creation with validation', async () => {
    // Test real database operations and business rules
    const response = await request(app.getHttpServer())
      .post('/v1/teams')
      .set('Authorization', `Bearer ${validJwt}`)
      .send(validTeamData)
      .expect(201);
      
    // Verify database state
    const team = await Team.findByPk(response.body.id);
    expect(team).toBeDefined();
  });
});
```

### Required Testing Commands

**Daily Development Workflow:**
```bash
# 1. Run unit tests continuously during development
npm run test:watch

# 2. Run unit tests before committing
npm test

# 3. Run comprehensive tests before pushing
npm run test:all-slow

# 4. Run specific test categories
npm run test:integration
npm run test:e2e
npm run test:security
npm run test:performance
```

### Test Coverage Requirements

- **Unit Tests:** Minimum 90% coverage for all services
- **Integration Tests:** Cover all critical business workflows
- **E2E Tests:** Cover all user-facing API endpoints
- **Security Tests:** Cover permission-based access control
- **Performance Tests:** Validate response times and database query efficiency

### Test Quality Standards

**MUST FOLLOW:**
1. **Arrange-Act-Assert (AAA) Pattern:** Structure all tests clearly
2. **Single Responsibility:** Each test validates one specific behavior
3. **Descriptive Names:** Test names explain the scenario and expected outcome
4. **Mock External Dependencies:** Never hit real APIs in unit tests
5. **Clean Test Data:** Use factories/fixtures for consistent test data
6. **Fast Feedback:** Unit tests must run quickly for rapid development

**FORBIDDEN:**
- Unit tests that hit real databases or external APIs
- Tests that depend on other tests (must be independent)
- Hardcoded test data (use factories and fixtures)
- Testing implementation details instead of behavior
- Skipping tests without valid justification

### Example TDD Workflow for New Feature

**Scenario: Implementing "Remove user from team" functionality**

```bash
# 1. Start with failing test
npm run test:watch

# 2. Write failing unit test
# test: should throw NotFoundException when user not in team

# 3. Write minimal code to pass
# Implementation: Basic user removal logic

# 4. Add more test cases (TDD cycle)
# test: should throw BadRequestException when removing last lawyer
# test: should successfully remove regular team member
# test: should update team member count

# 5. Run integration tests
npm run test:integration

# 6. Run full test suite before commit
npm test && npm run test:all-slow
```

This TDD approach ensures robust, maintainable code with comprehensive test coverage.

## 7. Database & Migrations

-   **STRICT RULE:** The database schema is managed **ONLY** by Sequelize migrations located in `/src/migrations`.
-   Never modify the database manually.
-   The workflow is:
    1.  Define or modify a model in `/src/modules/{feature}/entities/{entity}.entity.ts`.
    2.  Generate a new migration: `npx sequelize-cli migration:generate --name "feature-description"`.
    3.  Write the `up` and `down` methods in the new migration file using the query interface.
    4.  Run the migration locally: `npx sequelize-cli db:migrate`.

## 8. Example Request Walkthrough: Creating a Team

To tie it all together, here is the flow for `POST /v1/teams`:

1.  **Request In:** A `POST` request with a JSON body hits the server.
2.  **Global Guards:**
    -   `JwtAuthGuard` runs first. It validates the `Authorization: Bearer <token>` and attaches the user payload to `request.user`. If invalid, it rejects with 401.
    -   `PermissionsGuard` runs next. It checks the `@RequirePermissions('teams:create:own')` decorator on the controller method. It calls the `PermissionsService` to get the user's permissions. If the permission is missing, it rejects with 403.
3.  **Controller (`TeamController`):**
    -   The `createTeam` method is invoked.
    -   NestJS uses `class-validator` to validate the incoming body against the `CreateTeamDto`. If validation fails, it rejects with 400.
    -   The controller calls `this.teamService.create(createTeamDto, request.user)`. It does nothing else.
4.  **Service (`TeamService`):**
    -   The `create` method contains the business logic.
    -   It checks if a `VENDOR_ADMIN` is trying to create a team (based on `request.user`) and sets the `company_id` to the admin's own company.
    -   It verifies that the specified `owner_user_id` is a valid manager in that company by querying the `User` model.
    -   It calls the `Team` Sequelize model to create the new record in the database: `this.teamModel.create(...)`.
    -   It might call the `AuditService` to log the event.
    -   It returns the newly created team object.
5.  **Response Out:** The controller receives the new team object from the service and returns it. NestJS automatically sends a 201 Created response with the serialized object.